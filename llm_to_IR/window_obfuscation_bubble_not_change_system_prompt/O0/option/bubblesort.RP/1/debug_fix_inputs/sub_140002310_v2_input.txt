; === ERROR LOG BEGIN [llvm-as] ===
; llvm-as-14: assembly parsed, but does not verify as correct!
; PHI nodes not grouped at top of basic block!
;   %rcx.next = phi i64 [ %rcx.phi, %loop ], [ %39, %dec_rcx ]
; label %advance
; === ERROR LOG END ===

; ModuleID = 'pe_scan'
target triple = "x86_64-pc-windows-msvc"

@off_1400043C0 = external global i8*

define i32 @sub_140002310(i64 %rcx) {
entry:
  %0 = load i8*, i8** @off_1400043C0
  %1 = bitcast i8* %0 to i16*
  %2 = load i16, i16* %1
  %3 = icmp eq i16 %2, 23117
  br i1 %3, label %check_pe, label %ret0

check_pe:                                           ; preds = %entry
  %4 = getelementptr i8, i8* %0, i64 60
  %5 = bitcast i8* %4 to i32*
  %6 = load i32, i32* %5
  %7 = sext i32 %6 to i64
  %8 = getelementptr i8, i8* %0, i64 %7
  %9 = bitcast i8* %8 to i32*
  %10 = load i32, i32* %9
  %11 = icmp eq i32 %10, 17744
  br i1 %11, label %check_optmagic, label %ret0

check_optmagic:                                     ; preds = %check_pe
  %12 = getelementptr i8, i8* %8, i64 24
  %13 = bitcast i8* %12 to i16*
  %14 = load i16, i16* %13
  %15 = icmp eq i16 %14, 523
  br i1 %15, label %check_numsec, label %ret0

check_numsec:                                       ; preds = %check_optmagic
  %16 = getelementptr i8, i8* %8, i64 6
  %17 = bitcast i8* %16 to i16*
  %18 = load i16, i16* %17
  %19 = zext i16 %18 to i32
  %20 = icmp eq i32 %19, 0
  br i1 %20, label %ret0, label %calc_first

calc_first:                                         ; preds = %check_numsec
  %21 = getelementptr i8, i8* %8, i64 20
  %22 = bitcast i8* %21 to i16*
  %23 = load i16, i16* %22
  %24 = zext i16 %23 to i32
  %25 = zext i32 %24 to i64
  %26 = getelementptr i8, i8* %8, i64 %25
  %27 = getelementptr i8, i8* %26, i64 24
  %28 = zext i32 %19 to i64
  %29 = add i64 %28, -1
  %30 = mul i64 %29, 5
  %31 = mul i64 %30, 8
  %32 = getelementptr i8, i8* %27, i64 %31
  %33 = getelementptr i8, i8* %32, i64 40
  br label %loop

loop:                                               ; preds = %advance, %calc_first
  %curr = phi i8* [ %27, %calc_first ], [ %next, %advance ]
  %rcx.phi = phi i64 [ %rcx, %calc_first ], [ %rcx.next, %advance ]
  %34 = getelementptr i8, i8* %curr, i64 39
  %35 = load i8, i8* %34
  %36 = and i8 %35, 32
  %37 = icmp ne i8 %36, 0
  br i1 %37, label %check_rcx, label %advance

check_rcx:                                          ; preds = %loop
  %38 = icmp eq i64 %rcx.phi, 0
  br i1 %38, label %ret0, label %dec_rcx

dec_rcx:                                            ; preds = %check_rcx
  %39 = add i64 %rcx.phi, -1
  br label %advance

advance:                                            ; preds = %dec_rcx, %loop
  %next = getelementptr i8, i8* %curr, i64 40
  %rcx.next = phi i64 [ %rcx.phi, %loop ], [ %39, %dec_rcx ]
  %40 = icmp eq i8* %33, %next
  br i1 %40, label %ret0_with_zero, label %loop

ret0_with_zero:                                     ; preds = %advance
  br label %ret0

ret0:                                               ; preds = %ret0_with_zero, %check_rcx, %check_numsec, %check_optmagic, %check_pe, %entry
  ret i32 0
}