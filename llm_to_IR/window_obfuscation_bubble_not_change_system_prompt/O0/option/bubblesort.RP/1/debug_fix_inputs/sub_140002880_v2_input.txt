; === ERROR LOG BEGIN [llvm-as] ===
; llvm-as-14: ../../llm_to_IR/window_obfuscation_bubble_not_change_system_prompt/O0/option/bubblesort.RP/1/sub_1400028801.ll:65:15: error: expected instruction opcode
;   %newbound = %lastsw.exit
;               ^
; === ERROR LOG END ===

; ModuleID = 'recovered'
target triple = "x86_64-pc-windows-msvc"

@xmmword_140004010 = external constant <4 x i32>, align 16
@xmmword_140004020 = external constant <4 x i32>, align 16
@Format = internal constant [4 x i8] c"%d \00", align 1

declare void @sub_140001520()
declare i32 @sub_1400025A0(i8*, i32)
declare dllimport i32 @putchar(i32)

define i32 @sub_140002880() local_unnamed_addr {
entry:
  %arr = alloca [10 x i32], align 16
  call void @sub_140001520()
  %arr.vecptr = bitcast [10 x i32]* %arr to <4 x i32>*
  %vec1 = load <4 x i32>, <4 x i32>* @xmmword_140004010, align 16
  store <4 x i32> %vec1, <4 x i32>* %arr.vecptr, align 16
  %p4 = getelementptr inbounds [10 x i32], [10 x i32]* %arr, i64 0, i64 4
  %arr.vecptr2 = bitcast i32* %p4 to <4 x i32>*
  %vec2 = load <4 x i32>, <4 x i32>* @xmmword_140004020, align 16
  store <4 x i32> %vec2, <4 x i32>* %arr.vecptr2, align 16
  %idx8 = getelementptr inbounds [10 x i32], [10 x i32]* %arr, i64 0, i64 8
  store i32 4, i32* %idx8, align 4
  br label %outer

outer:                                            ; preds = %outer.back, %entry
  %bound = phi i32 [ 10, %entry ], [ %newbound, %outer.back ]
  br label %inner

inner:                                            ; preds = %inner.end, %outer
  %i = phi i32 [ 1, %outer ], [ %i.next, %inner.end ]
  %lastsw = phi i32 [ 0, %outer ], [ %lastsw.update, %inner.end ]
  %cmpi = icmp ne i32 %i, %bound
  br i1 %cmpi, label %do.compare, label %after.inner

do.compare:                                       ; preds = %inner
  %im1 = add nsw i32 %i, -1
  %p.im1 = getelementptr inbounds [10 x i32], [10 x i32]* %arr, i64 0, i32 %im1
  %p.i = getelementptr inbounds [10 x i32], [10 x i32]* %arr, i64 0, i32 %i
  %v1 = load i32, i32* %p.im1, align 4
  %v2 = load i32, i32* %p.i, align 4
  %need.swap = icmp slt i32 %v2, %v1
  br i1 %need.swap, label %swap, label %no.swap

swap:                                             ; preds = %do.compare
  store i32 %v2, i32* %p.im1, align 4
  store i32 %v1, i32* %p.i, align 4
  br label %inner.end

no.swap:                                          ; preds = %do.compare
  br label %inner.end

inner.end:                                        ; preds = %no.swap, %swap
  %lastsw.update = phi i32 [ %i, %swap ], [ %lastsw, %no.swap ]
  %i.next = add nsw i32 %i, 1
  br label %inner

after.inner:                                      ; preds = %inner
  %lastsw.exit = phi i32 [ %lastsw, %inner ]
  %cont = icmp ugt i32 %lastsw.exit, 1
  br i1 %cont, label %outer.back, label %print

outer.back:                                       ; preds = %after.inner
  %newbound = %lastsw.exit
  br label %outer

print:                                            ; preds = %after.inner
  %base = getelementptr inbounds [10 x i32], [10 x i32]* %arr, i64 0, i64 0
  %end = getelementptr inbounds [10 x i32], [10 x i32]* %arr, i64 0, i64 10
  br label %print.loop

print.loop:                                       ; preds = %print.loop, %print
  %p = phi i32* [ %base, %print ], [ %p.next, %print.loop ]
  %val = load i32, i32* %p, align 4
  %fmtptr = getelementptr inbounds [4 x i8], [4 x i8]* @Format, i64 0, i64 0
  %call.print = call i32 @sub_1400025A0(i8* %fmtptr, i32 %val)
  %p.next = getelementptr inbounds i32, i32* %p, i64 1
  %done = icmp eq i32* %p.next, %end
  br i1 %done, label %after.print, label %print.loop

after.print:                                      ; preds = %print.loop
  %call.nl = call dllimport i32 @putchar(i32 10)
  ret i32 0
}