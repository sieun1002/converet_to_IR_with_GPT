; === ERROR LOG BEGIN [llvm-as] ===
; llvm-as-14: ../../llm_to_IR/gpt_api_query/error_repeat/1/BFS_main1.ll:88:34: error: expected type
;   %fmt1 = getelementptr inbounds ([21 x i8], [21 x i8]* @.str.bfs, i64 0, i64 0
;                                  ^
; === ERROR LOG END ===

; ModuleID = 'recovered'
source_filename = "recovered.c"
target triple = "x86_64-unknown-linux-gnu"

@.str.bfs   = private unnamed_addr constant [21 x i8] c"BFS order from %zu: \00", align 1
@.str.pair  = private unnamed_addr constant [6 x i8] c"%zu%s\00", align 1
@.str.space = private unnamed_addr constant [2 x i8] c" \00", align 1
@.str.empty = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@.str.dist  = private unnamed_addr constant [23 x i8] c"dist(%zu -> %zu) = %d\0A\00", align 1

@__stack_chk_guard = external global i64

declare void @bfs(i32* nocapture, i64, i64, i32* nocapture, i64* nocapture, i64* nocapture)
declare i32 @printf(i8*, ...)
declare i32 @putchar(i32)
declare void @__stack_chk_fail() noreturn
declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i1 immarg)

define i32 @main() {
entry:
  %canary.slot = alloca i64, align 8
  %matrix = alloca [49 x i32], align 16
  %dist = alloca [7 x i32], align 16
  %order = alloca [7 x i64], align 16
  %order_len = alloca i64, align 8
  %n = alloca i64, align 8
  %start = alloca i64, align 8
  %k = alloca i64, align 8
  %i = alloca i64, align 8

  %guard = load i64, i64* @__stack_chk_guard
  store i64 %guard, i64* %canary.slot, align 8

  store i64 7, i64* %n, align 8

  ; zero matrix (49 * 4 = 196 bytes)
  %matrix.i8 = bitcast [49 x i32]* %matrix to i8*
  call void @llvm.memset.p0i8.i64(i8* %matrix.i8, i8 0, i64 196, i1 false)

  ; set undirected edges by linear index into 7x7 matrix
  %m0 = getelementptr inbounds [49 x i32], [49 x i32]* %matrix, i64 0, i64 1
  store i32 1, i32* %m0, align 4
  %m1 = getelementptr inbounds [49 x i32], [49 x i32]* %matrix, i64 0, i64 7
  store i32 1, i32* %m1, align 4

  %m2 = getelementptr inbounds [49 x i32], [49 x i32]* %matrix, i64 0, i64 2
  store i32 1, i32* %m2, align 4
  %m3 = getelementptr inbounds [49 x i32], [49 x i32]* %matrix, i64 0, i64 14
  store i32 1, i32* %m3, align 4

  %m4 = getelementptr inbounds [49 x i32], [49 x i32]* %matrix, i64 0, i64 10
  store i32 1, i32* %m4, align 4
  %m5 = getelementptr inbounds [49 x i32], [49 x i32]* %matrix, i64 0, i64 22
  store i32 1, i32* %m5, align 4

  %m6 = getelementptr inbounds [49 x i32], [49 x i32]* %matrix, i64 0, i64 11
  store i32 1, i32* %m6, align 4
  %m7 = getelementptr inbounds [49 x i32], [49 x i32]* %matrix, i64 0, i64 29
  store i32 1, i32* %m7, align 4

  %m8 = getelementptr inbounds [49 x i32], [49 x i32]* %matrix, i64 0, i64 19
  store i32 1, i32* %m8, align 4
  %m9 = getelementptr inbounds [49 x i32], [49 x i32]* %matrix, i64 0, i64 37
  store i32 1, i32* %m9, align 4

  %m10 = getelementptr inbounds [49 x i32], [49 x i32]* %matrix, i64 0, i64 33
  store i32 1, i32* %m10, align 4
  %m11 = getelementptr inbounds [49 x i32], [49 x i32]* %matrix, i64 0, i64 39
  store i32 1, i32* %m11, align 4

  %m12 = getelementptr inbounds [49 x i32], [49 x i32]* %matrix, i64 0, i64 41
  store i32 1, i32* %m12, align 4
  %m13 = getelementptr inbounds [49 x i32], [49 x i32]* %matrix, i64 0, i64 47
  store i32 1, i32* %m13, align 4

  store i64 0, i64* %start, align 8
  store i64 0, i64* %order_len, align 8

  %mat.ptr = getelementptr inbounds [49 x i32], [49 x i32]* %matrix, i64 0, i64 0
  %dist.ptr = getelementptr inbounds [7 x i32], [7 x i32]* %dist, i64 0, i64 0
  %order.ptr = getelementptr inbounds [7 x i64], [7 x i64]* %order, i64 0, i64 0
  %n.val = load i64, i64* %n, align 8
  %start.val = load i64, i64* %start, align 8

  call void @bfs(i32* %mat.ptr, i64 %n.val, i64 %start.val, i32* %dist.ptr, i64* %order.ptr, i64* %order_len)

  ; printf("BFS order from %zu: ", start)
  %fmt1 = getelementptr inbounds ([21 x i8], [21 x i8]* @.str.bfs, i64 0, i64 0
  )
  %start.val2 = load i64, i64* %start, align 8
  %call0 = call i32 (i8*, ...) @printf(i8* %fmt1, i64 %start.val2)

  ; for (k = 0; k < order_len; ++k) printf("%zu%s", order[k], sep)
  store i64 0, i64* %k, align 8
  br label %ord.cond

ord.cond:
  %k.cur = load i64, i64* %k, align 8
  %len = load i64, i64* %order_len, align 8
  %cmp = icmp ult i64 %k.cur, %len
  br i1 %cmp, label %ord.body, label %ord.end

ord.body:
  %kp1 = add i64 %k.cur, 1
  %cmp2 = icmp ult i64 %kp1, %len
  %sep.space = getelementptr inbounds ([2 x i8], [2 x i8]* @.str.space, i64 0, i64 0)
  %sep.empty = getelementptr inbounds ([1 x i8], [1 x i8]* @.str.empty, i64 0, i64 0)
  %sep = select i1 %cmp2, i8* %sep.space, i8* %sep.empty

  %ord.elem.ptr = getelementptr inbounds [7 x i64], [7 x i64]* %order, i64 0, i64 %k.cur
  %ord.elem = load i64, i64* %ord.elem.ptr, align 8

  %fmt2 = getelementptr inbounds ([6 x i8], [6 x i8]* @.str.pair, i64 0, i64 0)
  %call1 = call i32 (i8*, ...) @printf(i8* %fmt2, i64 %ord.elem, i8* %sep)

  %k.next = add i64 %k.cur, 1
  store i64 %k.next, i64* %k, align 8
  br label %ord.cond

ord.end:
  %nl = call i32 @putchar(i32 10)

  ; for (i = 0; i < n; ++i) printf("dist(%zu -> %zu) = %d\n", start, i, dist[i])
  store i64 0, i64* %i, align 8
  br label %dist.cond

dist.cond:
  %i.cur = load i64, i64* %i, align 8
  %n.cur = load i64, i64* %n, align 8
  %icmp = icmp ult i64 %i.cur, %n.cur
  br i1 %icmp, label %dist.body, label %ret.chk

dist.body:
  %dptr = getelementptr inbounds [7 x i32], [7 x i32]* %dist, i64 0, i64 %i.cur
  %dval = load i32, i32* %dptr, align 4
  %fmt3 = getelementptr inbounds ([23 x i8], [23 x i8]* @.str.dist, i64 0, i64 0)
  %start.val3 = load i64, i64* %start, align 8
  %call2 = call i32 (i8*, ...) @printf(i8* %fmt3, i64 %start.val3, i64 %i.cur, i32 %dval)
  %i.next = add i64 %i.cur, 1
  store i64 %i.next, i64* %i, align 8
  br label %dist.cond

ret.chk:
  %canary.loaded = load i64, i64* %canary.slot, align 8
  %guard.now = load i64, i64* @__stack_chk_guard
  %canary.bad = icmp ne i64 %canary.loaded, %guard.now
  br i1 %canary.bad, label %stack.fail, label %ret

stack.fail:
  call void @__stack_chk_fail()
  unreachable

ret:
  ret i32 0
}