; === ERROR LOG BEGIN [llvm-as] ===
; llvm-as-14: ../../llm_to_IR/gpt_api_error_analysis/O3/1/BFS_main1.ll:4:56: error: constant expression type mismatch: got type '[21 x i8]' but expected '[22 x i8]'
; @.str.header = private unnamed_addr constant [22 x i8] c"BFS order from %zu: \00", align 1
;                                                        ^
; === ERROR LOG END ===

; ModuleID = 'bfs_main'
target triple = "x86_64-unknown-linux-gnu"

@.str.header = private unnamed_addr constant [22 x i8] c"BFS order from %zu: \00", align 1
@.str.fmt_num = private unnamed_addr constant [6 x i8] c"%zu%s\00", align 1
@.str.space = private unnamed_addr constant [2 x i8] c" \00", align 1
@.str.empty = private unnamed_addr constant [1 x i8] c"\00", align 1
@.str.nl = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@.str.dist = private unnamed_addr constant [23 x i8] c"dist(%zu -> %zu) = %d\0A\00", align 1

; A sample undirected graph with 7 nodes:
; 0: 1,2
; 1: 0,3,4
; 2: 0,5,6
; 3: 1
; 4: 1
; 5: 2
; 6: 2
@G = private unnamed_addr constant [7 x [7 x i32]] [
  [7 x i32] [i32 0, i32 1, i32 1, i32 0, i32 0, i32 0, i32 0],
  [7 x i32] [i32 1, i32 0, i32 0, i32 1, i32 1, i32 0, i32 0],
  [7 x i32] [i32 1, i32 0, i32 0, i32 0, i32 0, i32 1, i32 1],
  [7 x i32] [i32 0, i32 1, i32 0, i32 0, i32 0, i32 0, i32 0],
  [7 x i32] [i32 0, i32 1, i32 0, i32 0, i32 0, i32 0, i32 0],
  [7 x i32] [i32 0, i32 0, i32 1, i32 0, i32 0, i32 0, i32 0],
  [7 x i32] [i32 0, i32 0, i32 1, i32 0, i32 0, i32 0, i32 0]
], align 16

declare i32 @__printf_chk(i32, i8*, ...) local_unnamed_addr

define i32 @main() local_unnamed_addr {
entry:
  %dist = alloca [7 x i32], align 16
  %queue = alloca [7 x i64], align 16
  %order = alloca [7 x i64], align 16
  %i.init = alloca i64, align 8
  %i2.init = alloca i64, align 8
  %i3.init = alloca i64, align 8
  store i64 0, i64* %i.init, align 8
  br label %init.loop

init.loop:                                           ; i from 0 to 6: dist[i] = -1
  %i.cur = load i64, i64* %i.init, align 8
  %cmp.init = icmp ult i64 %i.cur, 7
  br i1 %cmp.init, label %init.body, label %init.done

init.body:
  %dist.gep = getelementptr [7 x i32], [7 x i32]* %dist, i64 0, i64 %i.cur
  store i32 -1, i32* %dist.gep, align 4
  %i.next = add i64 %i.cur, 1
  store i64 %i.next, i64* %i.init, align 8
  br label %init.loop

init.done:
  %q0.ptr = getelementptr [7 x i64], [7 x i64]* %queue, i64 0, i64 0
  store i64 0, i64* %q0.ptr, align 8
  %d0.ptr = getelementptr [7 x i32], [7 x i32]* %dist, i64 0, i64 0
  store i32 0, i32* %d0.ptr, align 4
  %head = alloca i64, align 8
  %tail = alloca i64, align 8
  %ocnt = alloca i64, align 8
  store i64 0, i64* %head, align 8
  store i64 1, i64* %tail, align 8
  store i64 0, i64* %ocnt, align 8
  br label %bfs.cond

bfs.cond:
  %h.cur = load i64, i64* %head, align 8
  %t.cur = load i64, i64* %tail, align 8
  %cond = icmp ult i64 %h.cur, %t.cur
  br i1 %cond, label %bfs.body, label %bfs.done

bfs.body:
  %qv.ptr0 = getelementptr [7 x i64], [7 x i64]* %queue, i64 0, i64 %h.cur
  %v64 = load i64, i64* %qv.ptr0, align 8
  %h.next = add i64 %h.cur, 1
  store i64 %h.next, i64* %head, align 8
  %oc.cur = load i64, i64* %ocnt, align 8
  %o.ptr = getelementptr [7 x i64], [7 x i64]* %order, i64 0, i64 %oc.cur
  store i64 %v64, i64* %o.ptr, align 8
  %oc.next = add i64 %oc.cur, 1
  store i64 %oc.next, i64* %ocnt, align 8
  %v.trunc = trunc i64 %v64 to i32
  %v.ext = sext i32 %v.trunc to i64
  %dv.ptr = getelementptr [7 x i32], [7 x i32]* %dist, i64 0, i64 %v.ext
  %dv = load i32, i32* %dv.ptr, align 4
  store i64 0, i64* %i2.init, align 8
  br label %nbr.loop

nbr.loop:
  %k.cur = load i64, i64* %i2.init, align 8
  %k.cmp = icmp ult i64 %k.cur, 7
  br i1 %k.cmp, label %nbr.body, label %nbr.done

nbr.body:
  %row.ptr = getelementptr [7 x [7 x i32]], [7 x [7 x i32]]* @G, i64 0, i64 %v.ext
  %cell.ptr = getelementptr [7 x i32], [7 x i32]* %row.ptr, i64 0, i64 %k.cur
  %adj = load i32, i32* %cell.ptr, align 4
  %is.adj = icmp ne i32 %adj, 0
  br i1 %is.adj, label %check.unseen, label %next.k

check.unseen:
  %dk.ptr = getelementptr [7 x i32], [7 x i32]* %dist, i64 0, i64 %k.cur
  %dk = load i32, i32* %dk.ptr, align 4
  %is.unseen = icmp eq i32 %dk, -1
  br i1 %is.unseen, label %enqueue, label %next.k

enqueue:
  %t.enq = load i64, i64* %tail, align 8
  %q.enq.ptr = getelementptr [7 x i64], [7 x i64]* %queue, i64 0, i64 %t.enq
  store i64 %k.cur, i64* %q.enq.ptr, align 8
  %t.next = add i64 %t.enq, 1
  store i64 %t.next, i64* %tail, align 8
  %one = add i32 %dv, 1
  store i32 %one, i32* %dk.ptr, align 4
  br label %next.k

next.k:
  %k.next = add i64 %k.cur, 1
  store i64 %k.next, i64* %i2.init, align 8
  br label %nbr.loop

nbr.done:
  br label %bfs.cond

bfs.done:
  %fmt.hdr.ptr = getelementptr [22 x i8], [22 x i8]* @.str.header, i64 0, i64 0
  %fmt.hdr.i8 = bitcast [22 x i8]* @.str.header to i8*
  %call.hdr = call i32 (i32, i8*, ...) @__printf_chk(i32 2, i8* %fmt.hdr.i8, i64 0)
  %count.final = load i64, i64* %ocnt, align 8
  store i64 0, i64* %i3.init, align 8
  br label %print.loop

print.loop:
  %pi = load i64, i64* %i3.init, align 8
  %pi.cmp = icmp ult i64 %pi, %count.final
  br i1 %pi.cmp, label %print.body, label %print.done

print.body:
  %ord.ptr = getelementptr [7 x i64], [7 x i64]* %order, i64 0, i64 %pi
  %ord.val = load i64, i64* %ord.ptr, align 8
  %next.idx = add i64 %pi, 1
  %has.more = icmp ult i64 %next.idx, %count.final
  %sp.sel = select i1 %has.more, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.space, i64 0, i64 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.empty, i64 0, i64 0)
  %fmt.num.i8 = bitcast [6 x i8]* @.str.fmt_num to i8*
  %call.num = call i32 (i32, i8*, ...) @__printf_chk(i32 2, i8* %fmt.num.i8, i64 %ord.val, i8* %sp.sel)
  store i64 %next.idx, i64* %i3.init, align 8
  br label %print.loop

print.done:
  %fmt.nl.i8 = bitcast [2 x i8]* @.str.nl to i8*
  %call.nl = call i32 (i32, i8*, ...) @__printf_chk(i32 2, i8* %fmt.nl.i8)
  store i64 0, i64* %i.init, align 8
  br label %dist.loop

dist.loop:
  %di = load i64, i64* %i.init, align 8
  %di.cmp = icmp ult i64 %di, 7
  br i1 %di.cmp, label %dist.body, label %dist.done

dist.body:
  %d.ptr = getelementptr [7 x i32], [7 x i32]* %dist, i64 0, i64 %di
  %d.val = load i32, i32* %d.ptr, align 4
  %fmt.dist.i8 = bitcast [23 x i8]* @.str.dist to i8*
  %call.dist = call i32 (i32, i8*, ...) @__printf_chk(i32 2, i8* %fmt.dist.i8, i64 0, i64 %di, i32 %d.val)
  %di.next = add i64 %di, 1
  store i64 %di.next, i64* %i.init, align 8
  br label %dist.loop

dist.done:
  ret i32 0
}