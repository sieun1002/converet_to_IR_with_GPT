; === ERROR LOG BEGIN [llvm-as] ===
; llvm-as-14: ../../llm_to_IR/gpt_api_error_analysis_add_cfg/O3_2/1/BFS_main1.ll:5:44: error: constant expression type mismatch: got type '[21 x i8]' but expected '[22 x i8]'
; @.str_bfs_hdr = private constant [22 x i8] c"BFS order from %zu: \00"
;                                            ^
; === ERROR LOG END ===

; ModuleID = 'recovered'
target triple = "x86_64-unknown-linux-gnu"

@qword_2038 = external global i64
@.str_bfs_hdr = private constant [22 x i8] c"BFS order from %zu: \00"
@.str_zu_s   = private constant [6 x i8] c"%zu%s\00"
@.str_dist   = private constant [23 x i8] c"dist(%zu -> %zu) = %d\0A\00"
@.str_space  = private constant [2 x i8] c" \00"
@.str_empty  = private constant [1 x i8] c"\00"
@.str_nl     = private constant [2 x i8] c"\0A\00"

declare noalias i8* @malloc(i64)
declare void @free(i8*)
declare i32 @__printf_chk(i32, i8*, ...)
declare void @__stack_chk_fail()

declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i1)

define i32 @main() {
entry:                                             ; 0x10c0
  ; locals
  %dist = alloca [7 x i32], align 16
  %adj  = alloca [7 x [7 x i32]], align 16
  %saved = alloca [7 x i64], align 16
  %queue = alloca i64*, align 8
  %fmt_zu_s = alloca i8*, align 8
  ; stack canary (model)
  %canary.slot = alloca i64, align 8
  %guard.ptr = load i64, i64* bitcast (i64* @qword_2038 to i64*) ; dummy load to keep external sym alive
  ; emulate reading canary (use qword_2038 as placeholder-free; not actually checked)
  store i64 %guard.ptr, i64* %canary.slot, align 8

  ; initialize dist[] to -1
  %dist.i8 = bitcast [7 x i32]* %dist to i8*
  call void @llvm.memset.p0i8.i64(i8* %dist.i8, i8 -1, i64 28, i1 false)

  ; initialize adj[][] to 0
  %adj.i8 = bitcast [7 x [7 x i32]]* %adj to i8*
  call void @llvm.memset.p0i8.i64(i8* %adj.i8, i8 0, i64 196, i1 false)

  ; fill specific adj entries to 1 (as seen in stores)
  ; adj[1][0] = 1
  %adj_10 = getelementptr inbounds [7 x [7 x i32]], [7 x [7 x i32]]* %adj, i64 0, i64 1, i64 0
  store i32 1, i32* %adj_10, align 4
  ; adj[2][0] = 1
  %adj_20 = getelementptr inbounds [7 x [7 x i32]], [7 x [7 x i32]]* %adj, i64 0, i64 2, i64 0
  store i32 1, i32* %adj_20, align 4
  ; adj[3][1] = 1
  %adj_31 = getelementptr inbounds [7 x [7 x i32]], [7 x [7 x i32]]* %adj, i64 0, i64 3, i64 1
  store i32 1, i32* %adj_31, align 4
  ; adj[4][1] = 1
  %adj_41 = getelementptr inbounds [7 x [7 x i32]], [7 x [7 x i32]]* %adj, i64 0, i64 4, i64 1
  store i32 1, i32* %adj_41, align 4
  ; adj[2][5] = 1
  %adj_25 = getelementptr inbounds [7 x [7 x i32]], [7 x [7 x i32]]* %adj, i64 0, i64 2, i64 5
  store i32 1, i32* %adj_25, align 4
  ; adj[5][2] = 1
  %adj_52 = getelementptr inbounds [7 x [7 x i32]], [7 x [7 x i32]]* %adj, i64 0, i64 5, i64 2
  store i32 1, i32* %adj_52, align 4
  ; adj[4][5] = 1
  %adj_45 = getelementptr inbounds [7 x [7 x i32]], [7 x [7 x i32]]* %adj, i64 0, i64 4, i64 5
  store i32 1, i32* %adj_45, align 4
  ; adj[5][4] = 1
  %adj_54 = getelementptr inbounds [7 x [7 x i32]], [7 x [7 x i32]]* %adj, i64 0, i64 5, i64 4
  store i32 1, i32* %adj_54, align 4
  ; adj[5][6] = 1
  %adj_56 = getelementptr inbounds [7 x [7 x i32]], [7 x [7 x i32]]* %adj, i64 0, i64 5, i64 6
  store i32 1, i32* %adj_56, align 4
  ; adj[6][5] = 1
  %adj_65 = getelementptr inbounds [7 x [7 x i32]], [7 x [7 x i32]]* %adj, i64 0, i64 6, i64 5
  store i32 1, i32* %adj_65, align 4
  ; extra: adj[0][1] = trunc(qword_2038)
  %g = load i64, i64* @qword_2038
  %g32 = trunc i64 %g to i32
  %adj_01 = getelementptr inbounds [7 x [7 x i32]], [7 x [7 x i32]]* %adj, i64 0, i64 0, i64 1
  store i32 %g32, i32* %adj_01, align 4
  ; extra: adj[1][3] = trunc(qword_2038)
  %adj_13 = getelementptr inbounds [7 x [7 x i32]], [7 x [7 x i32]]* %adj, i64 0, i64 1, i64 3
  store i32 %g32, i32* %adj_13, align 4

  ; set up fmt pointer used later
  %fmtPtr = getelementptr inbounds [6 x i8], [6 x i8]* @.str_zu_s, i64 0, i64 0
  store i8* %fmtPtr, i8** %fmt_zu_s, align 8

  ; malloc 0x38
  %qmem = call noalias i8* @malloc(i64 56)           ; 0x1188
  %qnull = icmp eq i8* %qmem, null
  br i1 %qnull, label %L1414, label %L1196

L1196:                                            ; 0x1196
  %q = bitcast i8* %qmem to i64*
  store i64* %q, i64** %queue, align 8
  ; rsi = 1, rbx = 0
  ; queue[0] = 0
  %q0 = getelementptr inbounds i64, i64* %q, i64 0
  store i64 0, i64* %q0, align 8
  ; eax (col0 precomputed) = 0
  ; dist[0] = 0
  %dist0ptr = getelementptr inbounds [7 x i32], [7 x i32]* %dist, i64 0, i64 0
  store i32 0, i32* %dist0ptr, align 4
  br label %L11D3

L11C0:                                            ; 0x11c0
  ; precompute eax for next node: eax = adj[rdx][0]
  ; inputs via phi
  %phi.q.11C0 = phi i64* [ %phi.q.1320, %L1320 ]
  %phi.rbx.11C0 = phi i64 [ %rbx.next, %L1320 ]
  %phi.rsi.11C0 = phi i64 [ %phi.rsi.1320, %L1320 ]
  ; rdx = queue[rbx]
  %qidx.ptr = getelementptr inbounds i64, i64* %phi.q.11C0, i64 %phi.rbx.11C0
  %rdx.cur = load i64, i64* %qidx.ptr, align 8
  ; eax0 = adj[rdx][0]
  %row0.ptr = getelementptr inbounds [7 x [7 x i32]], [7 x [7 x i32]]* %adj, i64 0, i64 %rdx.cur, i64 0
  %eax0.next = load i32, i32* %row0.ptr, align 4
  br label %L11D3

L11D3:                                            ; 0x11d3
  ; phis for start of processing a node
  %phi.q.11D3 = phi i64* [ %q, %L1196 ], [ %phi.q.11C0, %L11C0 ]
  %phi.rsi.11D3 = phi i64 [ 1, %L1196 ], [ %phi.rsi.11C0, %L11C0 ]
  %phi.rbx.11D3.prev = phi i64 [ 0, %L1196 ], [ %phi.rbx.11C0, %L11C0 ]
  %phi.eax0.11D3 = phi i32 [ 0, %L1196 ], [ %eax0.next, %L11C0 ]
  ; rbx = rbx + 1
  %rbx.next = add i64 %phi.rbx.11D3.prev, 1
  ; rdx = queue[rbx-1]
  %idx.prev = sub i64 %rbx.next, 1
  %qpop.ptr = getelementptr inbounds i64, i64* %phi.q.11D3, i64 %idx.prev
  %rdx.node = load i64, i64* %qpop.ptr, align 8
  ; save popped node
  %saved.ptr = getelementptr inbounds [7 x i64], [7 x i64]* %saved, i64 0, i64 %idx.prev
  store i64 %rdx.node, i64* %saved.ptr, align 8
  br label %L11E1

L11E1:                                            ; 0x11e1
  ; test eax0
  %tst_eax0 = icmp eq i32 %phi.eax0.11D3, 0
  br i1 %tst_eax0, label %L1200, label %L11E5

L11E5:                                            ; 0x11e5
  ; if dist[0] != -1 -> skip
  %d0 = load i32, i32* %dist0ptr, align 4
  %d0_is_m1 = icmp ne i32 %d0, -1
  br i1 %d0_is_m1, label %L1200, label %L11EB

L11EB:                                            ; 0x11eb
  ; push neighbor 0 and set dist[0] = dist[rdx] + 1
  %parent.ptr.0 = getelementptr inbounds [7 x i32], [7 x i32]* %dist, i64 0, i64 %rdx.node
  %parent.0 = load i32, i32* %parent.ptr.0, align 4
  ; enqueue 0
  %enq.idx0 = getelementptr inbounds i64, i64* %phi.q.11D3, i64 %phi.rsi.11D3
  store i64 0, i64* %enq.idx0, align 8
  %rsi.inc0 = add i64 %phi.rsi.11D3, 1
  %newd0 = add i32 %parent.0, 1
  store i32 %newd0, i32* %dist0ptr, align 4
  br label %L1200

L1200:                                            ; 0x1200
  ; phi rsi after possible update
  %phi.rsi.1200 = phi i64 [ %phi.rsi.11D3, %L11E1 ], [ %phi.rsi.11D3, %L11E5 ], [ %rsi.inc0, %L11EB ]
  ; compute row base
  ; r11d = adj[rdx][1]
  %adj_r1 = getelementptr inbounds [7 x [7 x i32]], [7 x [7 x i32]]* %adj, i64 0, i64 %rdx.node, i64 1
  %r11d = load i32, i32* %adj_r1, align 4
  %tst_r11 = icmp eq i32 %r11d, 0
  br i1 %tst_r11, label %L1240, label %L121D

L121D:                                            ; 0x121d
  ; if dist[1] != -1 -> skip
  %dist1ptr = getelementptr inbounds [7 x i32], [7 x i32]* %dist, i64 0, i64 1
  %d1 = load i32, i32* %dist1ptr, align 4
  %d1_is_m1 = icmp ne i32 %d1, -1
  br i1 %d1_is_m1, label %L1240, label %L1224

L1224:                                            ; 0x1224
  %parent.1 = load i32, i32* %parent.ptr.0, align 4
  %enq.idx1 = getelementptr inbounds i64, i64* %phi.q.11D3, i64 %phi.rsi.1200
  store i64 1, i64* %enq.idx1, align 8
  %rsi.inc1 = add i64 %phi.rsi.1200, 1
  %newd1 = add i32 %parent.1, 1
  store i32 %newd1, i32* %dist1ptr, align 4
  br label %L1240

L1240:                                            ; 0x1240
  %phi.rsi.1240 = phi i64 [ %phi.rsi.1200, %L121D ], [ %rsi.inc1, %L1224 ], [ %phi.rsi.1200, %L1200 ]
  ; r10d = adj[rdx][2]
  %adj_r2 = getelementptr inbounds [7 x [7 x i32]], [7 x [7 x i32]]* %adj, i64 0, i64 %rdx.node, i64 2
  %r10d = load i32, i32* %adj_r2, align 4
  %tst_r10 = icmp eq i32 %r10d, 0
  br i1 %tst_r10, label %L1270, label %L124A

L124A:                                            ; 0x124a
  ; if dist[2] != -1 -> skip
  %dist2ptr = getelementptr inbounds [7 x i32], [7 x i32]* %dist, i64 0, i64 2
  %d2 = load i32, i32* %dist2ptr, align 4
  %d2_is_m1 = icmp ne i32 %d2, -1
  br i1 %d2_is_m1, label %L1270, label %L1251

L1251:                                            ; 0x1251
  %parent.2 = load i32, i32* %parent.ptr.0, align 4
  %enq.idx2 = getelementptr inbounds i64, i64* %phi.q.11D3, i64 %phi.rsi.1240
  store i64 2, i64* %enq.idx2, align 8
  %rsi.inc2 = add i64 %phi.rsi.1240, 1
  %newd2 = add i32 %parent.2, 1
  store i32 %newd2, i32* %dist2ptr, align 4
  br label %L1270

L1270:                                            ; 0x1270
  %phi.rsi.1270 = phi i64 [ %phi.rsi.1240, %L124A ], [ %rsi.inc2, %L1251 ], [ %phi.rsi.1240, %L1240 ]
  ; r9d = adj[rdx][3]
  %adj_r3 = getelementptr inbounds [7 x [7 x i32]], [7 x [7 x i32]]* %adj, i64 0, i64 %rdx.node, i64 3
  %r9d = load i32, i32* %adj_r3, align 4
  %tst_r9 = icmp eq i32 %r9d, 0
  br i1 %tst_r9, label %L12A0, label %L127A

L127A:                                            ; 0x127a
  ; if dist[3] != -1 -> skip
  %dist3ptr = getelementptr inbounds [7 x i32], [7 x i32]* %dist, i64 0, i64 3
  %d3 = load i32, i32* %dist3ptr, align 4
  %d3_is_m1 = icmp ne i32 %d3, -1
  br i1 %d3_is_m1, label %L12A0, label %L1281

L1281:                                            ; 0x1281
  %parent.3 = load i32, i32* %parent.ptr.0, align 4
  %enq.idx3 = getelementptr inbounds i64, i64* %phi.q.11D3, i64 %phi.rsi.1270
  store i64 3, i64* %enq.idx3, align 8
  %rsi.inc3 = add i64 %phi.rsi.1270, 1
  %newd3 = add i32 %parent.3, 1
  store i32 %newd3, i32* %dist3ptr, align 4
  br label %L12A0

L12A0:                                            ; 0x12a0
  %phi.rsi.12A0 = phi i64 [ %phi.rsi.1270, %L127A ], [ %rsi.inc3, %L1281 ], [ %phi.rsi.1270, %L1270 ]
  ; r8d = adj[rdx][4]
  %adj_r4 = getelementptr inbounds [7 x [7 x i32]], [7 x [7 x i32]]* %adj, i64 0, i64 %rdx.node, i64 4
  %r8d = load i32, i32* %adj_r4, align 4
  %tst_r8 = icmp eq i32 %r8d, 0
  br i1 %tst_r8, label %L12D0, label %L12AA

L12AA:                                            ; 0x12aa
  ; if dist[4] != -1 -> skip
  %dist4ptr = getelementptr inbounds [7 x i32], [7 x i32]* %dist, i64 0, i64 4
  %d4 = load i32, i32* %dist4ptr, align 4
  %d4_is_m1 = icmp ne i32 %d4, -1
  br i1 %d4_is_m1, label %L12D0, label %L12B1

L12B1:                                            ; 0x12b1
  %parent.4 = load i32, i32* %parent.ptr.0, align 4
  %enq.idx4 = getelementptr inbounds i64, i64* %phi.q.11D3, i64 %phi.rsi.12A0
  store i64 4, i64* %enq.idx4, align 8
  %rsi.inc4 = add i64 %phi.rsi.12A0, 1
  %newd4 = add i32 %parent.4, 1
  store i32 %newd4, i32* %dist4ptr, align 4
  br label %L12D0

L12D0:                                            ; 0x12d0
  %phi.rsi.12D0 = phi i64 [ %phi.rsi.12A0, %L12AA ], [ %rsi.inc4, %L12B1 ], [ %phi.rsi.12A0, %L12A0 ]
  ; ecx = adj[rdx][5]
  %adj_r5 = getelementptr inbounds [7 x [7 x i32]], [7 x [7 x i32]]* %adj, i64 0, i64 %rdx.node, i64 5
  %r5d = load i32, i32* %adj_r5, align 4
  %tst_r5 = icmp eq i32 %r5d, 0
  br i1 %tst_r5, label %L12F8, label %L12DF

L12DF:                                            ; 0x12df
  ; if dist[5] != -1 -> skip
  %dist5ptr = getelementptr inbounds [7 x i32], [7 x i32]* %dist, i64 0, i64 5
  %d5 = load i32, i32* %dist5ptr, align 4
  %d5_is_m1 = icmp ne i32 %d5, -1
  br i1 %d5_is_m1, label %L12F8, label %L12E2

L12E2:                                            ; 0x12e2
  %parent.5 = load i32, i32* %parent.ptr.0, align 4
  %enq.idx5 = getelementptr inbounds i64, i64* %phi.q.11D3, i64 %phi.rsi.12D0
  store i64 5, i64* %enq.idx5, align 8
  %rsi.inc5 = add i64 %phi.rsi.12D0, 1
  %newd5 = add i32 %parent.5, 1
  store i32 %newd5, i32* %dist5ptr, align 4
  br label %L12F8

L12F8:                                            ; 0x12f8
  %phi.rsi.12F8 = phi i64 [ %phi.rsi.12D0, %L12DF ], [ %rsi.inc5, %L12E2 ], [ %phi.rsi.12D0, %L12D0 ]
  ; eax = adj[rdx][6]
  %adj_r6 = getelementptr inbounds [7 x [7 x i32]], [7 x [7 x i32]]* %adj, i64 0, i64 %rdx.node, i64 6
  %r6d = load i32, i32* %adj_r6, align 4
  %tst_r6 = icmp eq i32 %r6d, 0
  br i1 %tst_r6, label %L1320, label %L1307

L1307:                                            ; 0x1307
  ; if dist[6] != -1 -> skip
  %dist6ptr = getelementptr inbounds [7 x i32], [7 x i32]* %dist, i64 0, i64 6
  %d6 = load i32, i32* %dist6ptr, align 4
  %d6_is_m1 = icmp ne i32 %d6, -1
  br i1 %d6_is_m1, label %L1320, label %L130A

L130A:                                            ; 0x130a
  %parent.6 = load i32, i32* %parent.ptr.0, align 4
  %enq.idx6 = getelementptr inbounds i64, i64* %phi.q.11D3, i64 %phi.rsi.12F8
  store i64 6, i64* %enq.idx6, align 8
  %rsi.inc6 = add i64 %phi.rsi.12F8, 1
  %newd6 = add i32 %parent.6, 1
  store i32 %newd6, i32* %dist6ptr, align 4
  br label %L1320

L1320:                                            ; 0x1320
  %phi.rsi.1320 = phi i64 [ %phi.rsi.12F8, %L12F8 ], [ %phi.rsi.12F8, %L1307 ], [ %rsi.inc6, %L130A ]
  ; compare rbx vs rsi to continue
  %cmp_rb = icmp ult i64 %rbx.next, %phi.rsi.1320
  br i1 %cmp_rb, label %L11C0, label %L1329

L1329:                                            ; 0x1329
  ; free(queue)
  %q.fin = phi i64* [ %phi.q.11D3, %L1320 ]
  %q.fin.i8 = bitcast i64* %q.fin to i8*
  call void @free(i8* %q.fin.i8)
  ; print header "BFS order from %zu: " with source = 0
  %hdrp = getelementptr inbounds [22 x i8], [22 x i8]* @.str_bfs_hdr, i64 0, i64 0
  %_ = call i32 (i32, i8*, ...) @__printf_chk(i32 2, i8* %hdrp, i64 0)
  ; load first saved element
  %saved0 = getelementptr inbounds [7 x i64], [7 x i64]* %saved, i64 0, i64 0
  %first = load i64, i64* %saved0, align 8
  ; rbx holds total count (equals rsi)
  %total = phi i64 [ %phi.rsi.1320, %L1320 ]
  %is_one = icmp ne i64 %total, 1
  br i1 %is_one, label %L13DD, label %L1360

L1360:                                            ; 0x1360
  ; print last (or only) element with empty suffix
  %fmt.ptr = load i8*, i8** %fmt_zu_s, align 8
  %empty = getelementptr inbounds [1 x i8], [1 x i8]* @.str_empty, i64 0, i64 0
  %__p1 = call i32 (i32, i8*, ...) @__printf_chk(i32 2, i8* %fmt.ptr, i64 %first, i8* %empty)
  br label %L1376

L1376:                                            ; 0x1376
  ; print newline
  %nlp = getelementptr inbounds [2 x i8], [2 x i8]* @.str_nl, i64 0, i64 0
  %__p2 = call i32 (i32, i8*, ...) @__printf_chk(i32 2, i8* %nlp)
  ; ebx = 0 -> start index for distances
  br label %L1398

L1398:                                            ; 0x1398
  ; loop i from 0..6 printing distances
  %i = phi i64 [ 0, %L1376 ], [ %i.next, %L13B4 ]
  %di = getelementptr inbounds [7 x i32], [7 x i32]* %dist, i64 0, i64 %i
  %val = load i32, i32* %di, align 4
  %fmtD = getelementptr inbounds [23 x i8], [23 x i8]* @.str_dist, i64 0, i64 0
  %__p3 = call i32 (i32, i8*, ...) @__printf_chk(i32 2, i8* %fmtD, i64 0, i64 %i, i32 %val)
  br label %L13B4

L13B4:                                            ; 0x13b4
  %i.next = add i64 %i, 1
  %cmp7 = icmp ne i64 %i.next, 7
  br i1 %cmp7, label %L1398, label %L13BA

L13BA:                                            ; 0x13ba
  ; canary check (modeled)
  %can.val = load i64, i64* %canary.slot, align 8
  %can.now = load i64, i64* bitcast (i64* @qword_2038 to i64*)
  %can.ok = icmp eq i64 %can.val, %can.now
  br i1 %can.ok, label %L13CD, label %L142E

L13CD:                                            ; 0x13cd
  ret i32 0

L13DD:                                            ; 0x13dd
  ; r12 = &saved[total]
  %saved.base = getelementptr inbounds [7 x i64], [7 x i64]* %saved, i64 0, i64 0
  %saved.end = getelementptr inbounds i64, i64* %saved.base, i64 %total
  ; rbp = &saved[1]
  %rbp = getelementptr inbounds i64, i64* %saved.base, i64 1
  %space = getelementptr inbounds [2 x i8], [2 x i8]* @.str_space, i64 0, i64 0
  %fmt.ptr2 = load i8*, i8** %fmt_zu_s, align 8
  br label %L13F0

L13F0:                                            ; 0x13f0
  ; print saved elements with trailing space until last
  %rbp.phi = phi i64* [ %rbp, %L13DD ], [ %rbp.next, %L140A ]
  %elem.ptr = getelementptr inbounds i64, i64* %rbp.phi, i64 -1
  %elem = load i64, i64* %elem.ptr, align 8
  %__p4 = call i32 (i32, i8*, ...) @__printf_chk(i32 2, i8* %fmt.ptr2, i64 %elem, i8* %space)
  br label %L1402

L1402:                                            ; 0x1402
  %rbp.next = getelementptr inbounds i64, i64* %rbp.phi, i64 1
  br label %L140A

L140A:                                            ; 0x140a
  %cont = icmp ne i64* %rbp.next, %saved.end
  ; keep rdx as last printed element is in %elem for final print
  %first.next = load i64, i64* %elem.ptr, align 8
  %first.sel = select i1 %cont, i64 %first, i64 %first.next
  br i1 %cont, label %L13F0, label %L1360

L1414:                                            ; 0x1414
  ; malloc failed: print header then jump to newline+distances
  %hdrp2 = getelementptr inbounds [22 x i8], [22 x i8]* @.str_bfs_hdr, i64 0, i64 0
  %__p5 = call i32 (i32, i8*, ...) @__printf_chk(i32 2, i8* %hdrp2, i64 0)
  br label %L1376

L142E:                                            ; 0x142e
  call void @__stack_chk_fail()
  unreachable
}