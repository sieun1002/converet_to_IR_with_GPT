; === ERROR LOG BEGIN [llvm-as] ===
; llvm-as-14: ../../llm_to_IR/gpt_api_error_analysis_add_cfg/O3_2/4/bubblesort_main1.ll:71:16: error: expected instruction opcode
;   %new_limit = %r8_end
;                ^
; === ERROR LOG END ===

; ModuleID = 'recovered'
target triple = "x86_64-unknown-linux-gnu"

@xmmword_2010 = external constant <4 x i32>, align 16
@xmmword_2020 = external constant <4 x i32>, align 16
@unk_2004 = external global i8
@unk_2008 = external global i8

declare i32 @___printf_chk(i32, i8*, ...)
declare void @___stack_chk_fail() noreturn

define i32 @main() {
entry_1080:
  %arr = alloca [10 x i32], align 16
  %canary = alloca i64, align 8
  %guard0 = call i64 asm sideeffect "movq %fs:0x28, $0", "=r"()
  store i64 %guard0, i64* %canary, align 8
  %arr.i32 = getelementptr inbounds [10 x i32], [10 x i32]* %arr, i64 0, i64 0
  %vecptr0 = bitcast i32* %arr.i32 to <4 x i32>*
  %v0 = load <4 x i32>, <4 x i32>* @xmmword_2010, align 16
  store <4 x i32> %v0, <4 x i32>* %vecptr0, align 16
  %ptr4 = getelementptr inbounds i32, i32* %arr.i32, i64 4
  %vecptr1 = bitcast i32* %ptr4 to <4 x i32>*
  %v1 = load <4 x i32>, <4 x i32>* @xmmword_2020, align 16
  store <4 x i32> %v1, <4 x i32>* %vecptr1, align 16
  %idx8 = getelementptr inbounds i32, i32* %arr.i32, i64 8
  store i32 4, i32* %idx8, align 4
  %idx9 = getelementptr inbounds i32, i32* %arr.i32, i64 9
  store i32 0, i32* %idx9, align 4
  br label %label_10d0

label_10d0:
  %limit = phi i64 [ 10, %entry_1080 ], [ %new_limit, %label_111c ]
  %rdx_init = phi i32* [ %arr.i32, %entry_1080 ], [ %arr.i32, %label_111c ]
  %rax_init = phi i64 [ 1, %entry_1080 ], [ 1, %label_111c ]
  %r8_init = phi i64 [ 0, %entry_1080 ], [ 0, %label_111c ]
  br label %label_10e0

label_10e0:
  %rdx_cur = phi i32* [ %rdx_init, %label_10d0 ], [ %rdx_next, %label_1101 ]
  %rax_cur = phi i64 [ %rax_init, %label_10d0 ], [ %rax_inc, %label_1101 ]
  %r8_cur = phi i64 [ %r8_init, %label_10d0 ], [ %r8_next, %label_1101 ]
  %a = load i32, i32* %rdx_cur, align 4
  %rdx_plus1 = getelementptr inbounds i32, i32* %rdx_cur, i64 1
  %b = load i32, i32* %rdx_plus1, align 4
  %cmp_le = icmp sle i32 %a, %b
  br i1 %cmp_le, label %label_1101, label %label_swap

label_swap:
  store i32 %b, i32* %rdx_cur, align 4
  store i32 %a, i32* %rdx_plus1, align 4
  br label %label_1101

label_1101:
  %r8_next = phi i64 [ %r8_cur, %label_10e0 ], [ %rax_cur, %label_swap ]
  %rax_inc = add i64 %rax_cur, 1
  %rdx_next = getelementptr inbounds i32, i32* %rdx_cur, i64 1
  %cmp_ne = icmp ne i64 %limit, %rax_inc
  br i1 %cmp_ne, label %label_10e0, label %label_110e

label_110e:
  %r8_end = phi i64 [ %r8_next, %label_1101 ]
  %is_zero = icmp eq i64 %r8_end, 0
  br i1 %is_zero, label %label_111e, label %label_check1

label_check1:
  %is_one = icmp eq i64 %r8_end, 1
  br i1 %is_one, label %label_111e, label %label_111c

label_111c:
  %new_limit = %r8_end
  br label %label_10d0

label_111e:
  %end_ptr = getelementptr inbounds i32, i32* %arr.i32, i64 10
  br label %label_1130

label_1130:
  %p_cur = phi i32* [ %arr.i32, %label_111e ], [ %p_next, %label_1130 ]
  %val = load i32, i32* %p_cur, align 4
  %call = call i32 (i32, i8*, ...) @___printf_chk(i32 2, i8* @unk_2004, i32 %val)
  %p_next = getelementptr inbounds i32, i32* %p_cur, i64 1
  %done = icmp eq i32* %p_next, %end_ptr
  br i1 %done, label %label_114a, label %label_1130

label_114a:
  %call2 = call i32 (i32, i8*, ...) @___printf_chk(i32 2, i8* @unk_2008)
  %saved = load i64, i64* %canary, align 8
  %guard1 = call i64 asm sideeffect "movq %fs:0x28, $0", "=r"()
  %cmp_guard = icmp ne i64 %saved, %guard1
  br i1 %cmp_guard, label %label_1178, label %label_ret

label_ret:
  ret i32 0

label_1178:
  call void @___stack_chk_fail()
  unreachable
}