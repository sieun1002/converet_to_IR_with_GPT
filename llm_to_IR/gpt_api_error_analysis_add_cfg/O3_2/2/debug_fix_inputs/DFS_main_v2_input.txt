; === ERROR LOG BEGIN [llvm-as] ===
; llvm-as-14: ../../llm_to_IR/gpt_api_error_analysis_add_cfg/O3_2/2/DFS_main1.ll:68:25: error: expected ',' after true destination
;   br i1 %ok01, label %11d7, label %1455
;                         ^
; === ERROR LOG END ===

; ModuleID = 'reconstructed'
target triple = "x86_64-pc-linux-gnu"
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"

@qword_2028 = external global i64
@__stack_chk_guard = external global i64
@.str_header = private constant [24 x i8] c"DFS preorder from %zu: \00"
@.str_nl = private constant [2 x i8] c"\0A\00"
@.str_fmt = private constant [6 x i8] c"%zu%s\00"

declare i8* @calloc(i64, i64)
declare i8* @malloc(i64)
declare void @free(i8*)
declare i32 @__printf_chk(i32, i8*, ...)
declare void @__stack_chk_fail()

define i32 @main() {
10e0:
  %canary.slot = alloca i64, align 8
  %arrF = alloca [64 x i32], align 16
  %visited_ptr = alloca i8*, align 8
  %next_ptr = alloca i8*, align 8
  %stack_ptr = alloca i8*, align 8
  %rdi_var = alloca i64, align 8
  %rbp_var = alloca i64, align 8
  %rdx_var = alloca i64, align 8
  %r8_ptr = alloca i64*, align 8
  %rsi_vis_ptr = alloca i32*, align 8
  %path = alloca [128 x i64], align 16
  %guard0 = load i64, i64* @__stack_chk_guard, align 8
  store i64 %guard0, i64* %canary.slot, align 8
  ; zero arrF (covers and exceeds the 24 qwords cleared in asm)
  %arrF.i8 = bitcast [64 x i32]* %arrF to i8*
  call void @llvm.memset.p0i8.i64(i8* %arrF.i8, i8 0, i64 256, i1 false)
  ; Initialize specific entries in arrF to 1 matching stack inits
  ; indices derived from offsets: 7, 14, 19, 22, 29, 33, 37, 39, 41, 47
  %a0 = getelementptr inbounds [64 x i32], [64 x i32]* %arrF, i64 0, i64 7
  store i32 1, i32* %a0, align 4
  %a1 = getelementptr inbounds [64 x i32], [64 x i32]* %arrF, i64 0, i64 14
  store i32 1, i32* %a1, align 4
  %a2 = getelementptr inbounds [64 x i32], [64 x i32]* %arrF, i64 0, i64 19
  store i32 1, i32* %a2, align 4
  %a3 = getelementptr inbounds [64 x i32], [64 x i32]* %arrF, i64 0, i64 22
  store i32 1, i32* %a3, align 4
  %a4 = getelementptr inbounds [64 x i32], [64 x i32]* %arrF, i64 0, i64 29
  store i32 1, i32* %a4, align 4
  %a5 = getelementptr inbounds [64 x i32], [64 x i32]* %arrF, i64 0, i64 33
  store i32 1, i32* %a5, align 4
  %a6 = getelementptr inbounds [64 x i32], [64 x i32]* %arrF, i64 0, i64 37
  store i32 1, i32* %a6, align 4
  %a7 = getelementptr inbounds [64 x i32], [64 x i32]* %arrF, i64 0, i64 39
  store i32 1, i32* %a7, align 4
  %a8 = getelementptr inbounds [64 x i32], [64 x i32]* %arrF, i64 0, i64 41
  store i32 1, i32* %a8, align 4
  %a9 = getelementptr inbounds [64 x i32], [64 x i32]* %arrF, i64 0, i64 47
  store i32 1, i32* %a9, align 4
  ; allocate structures
  %p0 = call i8* @calloc(i64 28, i64 1)
  store i8* %p0, i8** %visited_ptr, align 8
  %p1 = call i8* @calloc(i64 56, i64 1)
  store i8* %p1, i8** %next_ptr, align 8
  %p2 = call i8* @malloc(i64 56)
  store i8* %p2, i8** %stack_ptr, align 8
  ; null checks -> 1455
  %ok0 = icmp ne i8* %p0, null
  %ok1 = icmp ne i8* %p1, null
  %ok01 = and i1 %ok0, %ok1
  br i1 %ok01, label %11d7, label %1455

11d7:                                             ; preds = %10e0
  %ok2 = icmp ne i8* %p2, null
  br i1 %ok2, label %11e0, label %1455

11e0:                                             ; preds = %11d7
  ; stack[0] = 0
  %stack64 = bitcast i8* %p2 to i64*
  store i64 0, i64* %stack64, align 8
  ; edx = 0 (rdx_var)
  store i64 0, i64* %rdx_var, align 8
  ; rbp = 1
  store i64 1, i64* %rbp_var, align 8
  ; rdi = 1
  store i64 1, i64* %rdi_var, align 8
  ; visited[0] = 1
  %vis32 = bitcast i8* %p0 to i32*
  store i32 1, i32* %vis32, align 4
  ; path[0] = 0
  %path0 = getelementptr inbounds [128 x i64], [128 x i64]* %path, i64 0, i64 0
  store i64 0, i64* %path0, align 8
  br label %120d

1208:                                             ; preds = %1341, %1412, %133d
  ; rdx = stack[rdi-1]
  %stkP = load i8*, i8** %stack_ptr, align 8
  %stk64 = bitcast i8* %stkP to i64*
  %di_now = load i64, i64* %rdi_var, align 8
  %di_dec = add i64 %di_now, -1
  %tos.ptr = getelementptr inbounds i64, i64* %stk64, i64 %di_dec
  %tos = load i64, i64* %tos.ptr, align 8
  store i64 %tos, i64* %rdx_var, align 8
  br label %120d

120d:                                             ; preds = %11e0, %1208
  ; rcx7 = rdx*7, r8 = &next[rdx], rax = *r8
  %rdx_now = load i64, i64* %rdx_var, align 8
  %rcx7 = mul i64 %rdx_now, 7
  %nextP = load i8*, i8** %next_ptr, align 8
  %next64 = bitcast i8* %nextP to i64*
  %r8.gep = getelementptr inbounds i64, i64* %next64, i64 %rdx_now
  store i64* %r8.gep, i64** %r8_ptr, align 8
  %rax0 = load i64, i64* %r8.gep, align 8
  ; if (rax0 > 6) goto 1412
  %cmp.ugt6 = icmp ugt i64 %rax0, 6
  br i1 %cmp.ugt6, label %1412, label %1227

1227:                                             ; preds = %120d
  ; idx = rax0 + rcx7
  %idx0 = add i64 %rax0, %rcx7
  ; t = arrF[idx0]
  %arrF.i32 = getelementptr inbounds [64 x i32], [64 x i32]* %arrF, i64 0, i64 %idx0
  %t0 = load i32, i32* %arrF.i32, align 4
  %t0z = icmp eq i32 %t0, 0
  br i1 %t0z, label %1248, label %1238

1238:                                             ; preds = %1227
  ; if visited[rax0] == 0 -> 13EA
  %visP = load i8*, i8** %visited_ptr, align 8
  %vis32b = bitcast i8* %visP to i32*
  %vptr0 = getelementptr inbounds i32, i32* %vis32b, i64 %rax0
  %v0 = load i32, i32* %vptr0, align 4
  %v0z = icmp eq i32 %v0, 0
  br i1 %v0z, label %13ea, label %1248

1248:                                             ; preds = %1238, %1227
  ; check rax0+1 within bound and available
  %rdx1 = add i64 %rax0, 1
  %is6 = icmp eq i64 %rax0, 6
  br i1 %is6, label %133d, label %1256

1256:                                             ; preds = %1248
  %idx1 = add i64 %rcx7, %rdx1
  %a1p = getelementptr inbounds [64 x i32], [64 x i32]* %arrF, i64 0, i64 %idx1
  %t1 = load i32, i32* %a1p, align 4
  %t1z = icmp eq i32 %t1, 0
  br i1 %t1z, label %1274, label %1264

1264:                                             ; preds = %1256
  %visP1 = load i8*, i8** %visited_ptr, align 8
  %vis32c = bitcast i8* %visP1 to i32*
  %vptr1 = getelementptr inbounds i32, i32* %vis32c, i64 %rdx1
  %v1 = load i32, i32* %vptr1, align 4
  %v1z = icmp eq i32 %v1, 0
  br i1 %v1z, label %to13f0_rdx1, label %1274

to13f0_rdx1:                                      ; preds = %1264
  store i64 %rdx1, i64* %rdx_var, align 8
  store i32* %vptr1, i32** %rsi_vis_ptr, align 8
  br label %13f0

1274:                                             ; preds = %1264, %1256
  %rdx2 = add i64 %rax0, 2
  %is5 = icmp eq i64 %rax0, 5
  br i1 %is5, label %133d, label %1282

1282:                                             ; preds = %1274
  %idx2 = add i64 %rcx7, %rdx2
  %a2p = getelementptr inbounds [64 x i32], [64 x i32]* %arrF, i64 0, i64 %idx2
  %t2 = load i32, i32* %a2p, align 4
  %t2z = icmp eq i32 %t2, 0
  br i1 %t2z, label %12a0, label %1290

1290:                                             ; preds = %1282
  %visP2 = load i8*, i8** %visited_ptr, align 8
  %vis32d = bitcast i8* %visP2 to i32*
  %vptr2 = getelementptr inbounds i32, i32* %vis32d, i64 %rdx2
  %v2 = load i32, i32* %vptr2, align 4
  %v2z = icmp eq i32 %v2, 0
  br i1 %v2z, label %to13f0_rdx2, label %12a0

to13f0_rdx2:                                      ; preds = %1290
  store i64 %rdx2, i64* %rdx_var, align 8
  store i32* %vptr2, i32** %rsi_vis_ptr, align 8
  br label %13f0

12a0:                                             ; preds = %1290, %1282
  %rdx3 = add i64 %rax0, 3
  %is4 = icmp eq i64 %rax0, 4
  br i1 %is4, label %133d, label %12ae

12ae:                                             ; preds = %12a0
  %idx3 = add i64 %rcx7, %rdx3
  %a3p = getelementptr inbounds [64 x i32], [64 x i32]* %arrF, i64 0, i64 %idx3
  %t3 = load i32, i32* %a3p, align 4
  %t3z = icmp eq i32 %t3, 0
  br i1 %t3z, label %12cc, label %12bc

12bc:                                             ; preds = %12ae
  %visP3 = load i8*, i8** %visited_ptr, align 8
  %vis32e = bitcast i8* %visP3 to i32*
  %vptr3 = getelementptr inbounds i32, i32* %vis32e, i64 %rdx3
  %v3 = load i32, i32* %vptr3, align 4
  %v3z = icmp eq i32 %v3, 0
  br i1 %v3z, label %to13f0_rdx3, label %12cc

to13f0_rdx3:                                      ; preds = %12bc
  store i64 %rdx3, i64* %rdx_var, align 8
  store i32* %vptr3, i32** %rsi_vis_ptr, align 8
  br label %13f0

12cc:                                             ; preds = %12bc, %12ae
  %rdx4 = add i64 %rax0, 4
  %is3 = icmp eq i64 %rax0, 3
  br i1 %is3, label %133d, label %12d6

12d6:                                             ; preds = %12cc
  %idx4 = add i64 %rcx7, %rdx4
  %a4p = getelementptr inbounds [64 x i32], [64 x i32]* %arrF, i64 0, i64 %idx4
  %t4 = load i32, i32* %a4p, align 4
  %t4z = icmp eq i32 %t4, 0
  br i1 %t4z, label %12f4, label %12e4

12e4:                                             ; preds = %12d6
  %visP4 = load i8*, i8** %visited_ptr, align 8
  %vis32f = bitcast i8* %visP4 to i32*
  %vptr4 = getelementptr inbounds i32, i32* %vis32f, i64 %rdx4
  %v4 = load i32, i32* %vptr4, align 4
  %v4z = icmp eq i32 %v4, 0
  br i1 %v4z, label %to13f0_rdx4, label %12f4

to13f0_rdx4:                                      ; preds = %12e4
  store i64 %rdx4, i64* %rdx_var, align 8
  store i32* %vptr4, i32** %rsi_vis_ptr, align 8
  br label %13f0

12f4:                                             ; preds = %12e4, %12d6
  %rdx5 = add i64 %rax0, 5
  %is2 = icmp eq i64 %rax0, 2
  br i1 %is2, label %133d, label %12fe

12fe:                                             ; preds = %12f4
  %idx5 = add i64 %rcx7, %rdx5
  %a5p = getelementptr inbounds [64 x i32], [64 x i32]* %arrF, i64 0, i64 %idx5
  %t5 = load i32, i32* %a5p, align 4
  %t5z = icmp eq i32 %t5, 0
  br i1 %t5z, label %131c, label %130c

130c:                                             ; preds = %12fe
  %visP5 = load i8*, i8** %visited_ptr, align 8
  %vis32g = bitcast i8* %visP5 to i32*
  %vptr5 = getelementptr inbounds i32, i32* %vis32g, i64 %rdx5
  %v5 = load i32, i32* %vptr5, align 4
  %v5z = icmp eq i32 %v5, 0
  br i1 %v5z, label %to13f0_rdx5, label %131c

to13f0_rdx5:                                      ; preds = %130c
  store i64 %rdx5, i64* %rdx_var, align 8
  store i32* %vptr5, i32** %rsi_vis_ptr, align 8
  br label %13f0

13ea:                                             ; preds = %1238
  ; select rax0 as next
  store i64 %rax0, i64* %rdx_var, align 8
  ; rsi = &visited[rax0]
  %visP0 = load i8*, i8** %visited_ptr, align 8
  %vis32h = bitcast i8* %visP0 to i32*
  %vptr0b = getelementptr inbounds i32, i32* %vis32h, i64 %rax0
  store i32* %vptr0b, i32** %rsi_vis_ptr, align 8
  br label %13f0

131c:                                             ; preds = %130c, %12fe
  ; if rax0 != 0 -> 133d
  %rax0nz = icmp ne i64 %rax0, 0
  br i1 %rax0nz, label %133d, label %1321

1321:                                             ; preds = %131c
  ; edx = arrF[rcx7 + 6]
  %idxE0 = add i64 %rcx7, 6
  %aE0p = getelementptr inbounds [64 x i32], [64 x i32]* %arrF, i64 0, i64 %idxE0
  %tE0 = load i32, i32* %aE0p, align 4
  %tE0z = icmp eq i32 %tE0, 0
  br i1 %tE0z, label %133d, label %1329

1329:                                             ; preds = %1321
  ; eax = visited[6], rsi = &visited[6], edx = 6
  %visP6 = load i8*, i8** %visited_ptr, align 8
  %vis32i = bitcast i8* %visP6 to i32*
  %vptr6 = getelementptr inbounds i32, i32* %vis32i, i64 6
  %v6 = load i32, i32* %vptr6, align 4
  store i32* %vptr6, i32** %rsi_vis_ptr, align 8
  store i64 6, i64* %rdx_var, align 8
  %v6z = icmp eq i32 %v6, 0
  br i1 %v6z, label %13f0, label %133d

13f0:                                             ; preds = %to13f0_rdx5, %to13f0_rdx4, %to13f0_rdx3, %to13f0_rdx2, %to13f0_rdx1, %1329, %13ea
  ; push rdx, update structures
  %rdx_new = load i64, i64* %rdx_var, align 8
  %rax_next = add i64 %rdx_new, 1
  ; path[rbp] = rdx_new
  %rbp_now = load i64, i64* %rbp_var, align 8
  %path.slot = getelementptr inbounds [128 x i64], [128 x i64]* %path, i64 0, i64 %rbp_now
  store i64 %rdx_new, i64* %path.slot, align 8
  ; rbp++
  %rbp_inc = add i64 %rbp_now, 1
  store i64 %rbp_inc, i64* %rbp_var, align 8
  ; stack[rdi] = rdx_new
  %stkP2 = load i8*, i8** %stack_ptr, align 8
  %stk64b = bitcast i8* %stkP2 to i64*
  %di_now2 = load i64, i64* %rdi_var, align 8
  %stkslot = getelementptr inbounds i64, i64* %stk64b, i64 %di_now2
  store i64 %rdx_new, i64* %stkslot, align 8
  ; rdi++
  %di_inc = add i64 %di_now2, 1
  store i64 %di_inc, i64* %rdi_var, align 8
  ; *r8 = rdx_new + 1
  %r8p_now = load i64*, i64** %r8_ptr, align 8
  store i64 %rax_next, i64* %r8p_now, align 8
  ; visited[rdx_new] = 1
  %vptrN = load i32*, i32** %rsi_vis_ptr, align 8
  store i32 1, i32* %vptrN, align 4
  br label %1341

1412:                                             ; preds = %120d
  ; if rax0 == 7 -> 133d else continue loop
  %is7 = icmp eq i64 %rax0, 7
  br i1 %is7, label %133d, label %1208

133d:                                             ; preds = %1412, %1329, %1321, %131c, %12f4, %12cc, %12a0, %1274, %1248
  ; rdi--
  %di_now3 = load i64, i64* %rdi_var, align 8
  %di_sub = add i64 %di_now3, -1
  store i64 %di_sub, i64* %rdi_var, align 8
  br label %1341

1341:                                             ; preds = %13f0, %133d
  ; if (rdi != 0) continue loop
  %di_chk = load i64, i64* %rdi_var, align 8
  %di_nz = icmp ne i64 %di_chk, 0
  br i1 %di_nz, label %1208, label %134a

134a:                                             ; preds = %1341
  ; free visited, next, stack
  %pv = load i8*, i8** %visited_ptr, align 8
  call void @free(i8* %pv)
  %pn = load i8*, i8** %next_ptr, align 8
  call void @free(i8* %pn)
  %ps = load i8*, i8** %stack_ptr, align 8
  call void @free(i8* %ps)
  ; print header: "DFS preorder from %zu: " with starting node 0
  ; edx = 0, eax = 0 in asm; pass %zu argument = 0
  %hdrp = getelementptr inbounds [24 x i8], [24 x i8]* @.str_header, i64 0, i64 0
  %zero64 = add i64 0, 0
  %_ = call i32 (i32, i8*, ...) @__printf_chk(i32 2, i8* %hdrp, i64 %zero64)
  ; if (rbp == 0) -> 13ae
  %rbp_now2 = load i64, i64* %rbp_var, align 8
  %rbp_z = icmp eq i64 %rbp_now2, 0
  br i1 %rbp_z, label %13ae, label %137c

137c:                                             ; preds = %134a
  ; rdx = path[0]
  %p0v = load i64, i64* %path0, align 8
  ; r12 = "%zu%s" (we reuse %fmt pointer value via a local)
  %fmtp = getelementptr inbounds [6 x i8], [6 x i8]* @.str_fmt, i64 0, i64 0
  ; if (rbp != 1) -> 1421 else -> 1398
  %rbp_is1 = icmp eq i64 %rbp_now2, 1
  br i1 %rbp_is1, label %1398, label %1421

1398:                                             ; preds = %1421.1450, %137c
  ; print first element with empty suffix
  %empty = getelementptr inbounds [2 x i8], [2 x i8]* @.str_nl, i64 0, i64 1
  %_p0 = call i32 (i32, i8*, ...) @__printf_chk(i32 2, i8* %fmtp, i64 %p0v, i8* %empty)
  br label %13ae

1421:                                             ; preds = %137c
  ; loop over path elements [1..rbp-1], separated by " "
  ; rbx = 1
  %i0 = add i64 0, 1
  ; r14 = &" " inside header literal at offset 22
  %spc = getelementptr inbounds [24 x i8], [24 x i8]* @.str_header, i64 0, i64 22
  br label %1430

1430:                                             ; preds = %144e, %1421
  ; load path[i-1]
  %i.phi = phi i64 [ %i0, %1421 ], [ %i.next, %144e ]
  %idxPath = add i64 %i.phi, -1
  %pelem.ptr = getelementptr inbounds [128 x i64], [128 x i64]* %path, i64 0, i64 %idxPath
  %pelem = load i64, i64* %pelem.ptr, align 8
  %_p = call i32 (i32, i8*, ...) @__printf_chk(i32 2, i8* %fmtp, i64 %pelem, i8* %spc)
  ; i++
  %i.next = add i64 %i.phi, 1
  ; if (i != rbp) loop
  %rbp_now3 = load i64, i64* %rbp_var, align 8
  %cont = icmp ne i64 %i.next, %rbp_now3
  br i1 %cont, label %144e, label %1450

144e:                                             ; preds = %1430
  br label %1430

1450:                                             ; preds = %1430
  br label %1398

1455:                                             ; preds = %11d7, %10e0
  ; free any non-null, then print header and newline only
  %pvE = phi i8* [ %p0, %10e0 ], [ %p0, %11d7 ]
  %pnE = phi i8* [ %p1, %10e0 ], [ %p1, %11d7 ]
  %psE = phi i8* [ %p2, %11d7 ], [ null, %10e0 ]
  ; free visited if non-null
  %v.nn = icmp ne i8* %pvE, null
  br i1 %v.nn, label %1455.freev, label %1455.afv

1455.freev:                                       ; preds = %1455
  call void @free(i8* %pvE)
  br label %1455.afv

1455.afv:                                         ; preds = %1455.freev, %1455
  %n.nn = icmp ne i8* %pnE, null
  br i1 %n.nn, label %1455.freen, label %1455.afn

1455.freen:                                       ; preds = %1455.afv
  call void @free(i8* %pnE)
  br label %1455.afn

1455.afn:                                         ; preds = %1455.freen, %1455.afv
  %s.nn = icmp ne i8* %psE, null
  br i1 %s.nn, label %1455.frees, label %146d

1455.frees:                                       ; preds = %1455.afn
  call void @free(i8* %psE)
  br label %146d

146d:                                             ; preds = %1455.frees, %1455.afn
  ; edx = 0; print header with 0
  %hdrpE = getelementptr inbounds [24 x i8], [24 x i8]* @.str_header, i64 0, i64 0
  %zeroE = add i64 0, 0
  %_E = call i32 (i32, i8*, ...) @__printf_chk(i32 2, i8* %hdrpE, i64 %zeroE)
  br label %13ae

13ae:                                             ; preds = %146d, %1398, %134a
  ; print newline
  %nlp = getelementptr inbounds [2 x i8], [2 x i8]* @.str_nl, i64 0, i64 0
  %_nl = call i32 (i32, i8*, ...) @__printf_chk(i32 2, i8* %nlp)
  ; check canary
  %guard1 = load i64, i64* @__stack_chk_guard, align 8
  %guard.stored = load i64, i64* %canary.slot, align 8
  %canary.bad = icmp ne i64 %guard.stored, %guard1
  br i1 %canary.bad, label %1487, label %13d8

1487:                                             ; preds = %13ae
  call void @__stack_chk_fail()
  unreachable

13d8:                                             ; preds = %13ae
  ret i32 0
}

declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i1 immarg)