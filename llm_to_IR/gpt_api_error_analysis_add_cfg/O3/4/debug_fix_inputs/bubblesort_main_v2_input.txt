; === ERROR LOG BEGIN [llvm-as] ===
; llvm-as-14: ../../llm_to_IR/gpt_api_error_analysis_add_cfg/O3/4/bubblesort_main1.ll:58:18: error: invalid cast opcode for cast from 'i64' to 'i64'
;   %r8.new = sext i64 %rax.cur to i64
;                  ^
; === ERROR LOG END ===

; ModuleID = 'recovered'
target triple = "x86_64-pc-linux-gnu"

%struct.Frame = type { [16 x i8], [16 x i8], i32, i32, i64 }

@xmmword_2010 = external constant [16 x i8], align 16
@xmmword_2020 = external constant [16 x i8], align 16
@unk_2004     = external constant [0 x i8]
@unk_2008     = external constant [0 x i8]
@__stack_chk_guard = external global i64, align 8

declare i32 @__printf_chk(i32, i8*, ...)
declare void @__stack_chk_fail() noreturn

define i32 @main() {
L1080:
  %frame = alloca %struct.Frame, align 16
  %var48.ptr = getelementptr inbounds %struct.Frame, %struct.Frame* %frame, i64 0, i32 0
  %var38.ptr = getelementptr inbounds %struct.Frame, %struct.Frame* %frame, i64 0, i32 1
  %var28.ptr = getelementptr inbounds %struct.Frame, %struct.Frame* %frame, i64 0, i32 2
  %var20.ptr = getelementptr inbounds %struct.Frame, %struct.Frame* %frame, i64 0, i32 4
  %rbx.base.i8 = bitcast %struct.Frame* %frame to i8*
  %guard.init = load i64, i64* @__stack_chk_guard, align 8
  store i64 %guard.init, i64* %var20.ptr, align 8
  %g1.vec.ptr = bitcast [16 x i8]* @xmmword_2010 to <2 x i64>*
  %g2.vec.ptr = bitcast [16 x i8]* @xmmword_2020 to <2 x i64>*
  %v1 = load <2 x i64>, <2 x i64>* %g1.vec.ptr, align 16
  %v2 = load <2 x i64>, <2 x i64>* %g2.vec.ptr, align 16
  %var48.vec.ptr = bitcast [16 x i8]* %var48.ptr to <2 x i64>*
  %var38.vec.ptr = bitcast [16 x i8]* %var38.ptr to <2 x i64>*
  store <2 x i64> %v1, <2 x i64>* %var48.vec.ptr, align 16
  store <2 x i64> %v2, <2 x i64>* %var38.vec.ptr, align 16
  store i32 4, i32* %var28.ptr, align 4
  br label %loc_10D0

loc_10D0:                                           ; preds = %L1080, %bb_1119
  %rdi.loop = phi i64 [ 10, %L1080 ], [ %r8.pass.110E, %bb_1119 ]
  %rdx.start = bitcast i8* %rbx.base.i8 to i8*
  %r8.init = phi i64 [ 0, %L1080 ], [ 0, %bb_1119 ]
  %rax.init = phi i64 [ 1, %L1080 ], [ 1, %bb_1119 ]
  br label %loc_10E0

loc_10E0:                                           ; preds = %loc_1101, %loc_10D0
  %rdx.cur = phi i8* [ %rdx.next, %loc_1101 ], [ %rdx.start, %loc_10D0 ]
  %rax.cur = phi i64 [ %rax.next, %loc_1101 ], [ %rax.init, %loc_10D0 ]
  %r8.cur = phi i64 [ %r8.after, %loc_1101 ], [ %r8.init, %loc_10D0 ]
  %ptr.a.i32 = bitcast i8* %rdx.cur to i32*
  %a = load i32, i32* %ptr.a.i32, align 4
  %rdx.plus4 = getelementptr inbounds i8, i8* %rdx.cur, i64 4
  %ptr.b.i32 = bitcast i8* %rdx.plus4 to i32*
  %b = load i32, i32* %ptr.b.i32, align 4
  %cmp_le = icmp sle i32 %a, %b
  br i1 %cmp_le, label %loc_1101, label %bb_swap

bb_swap:                                            ; swap path for a > b
  store i32 %b, i32* %ptr.a.i32, align 4
  store i32 %a, i32* %ptr.b.i32, align 4
  %r8.new = sext i64 %rax.cur to i64
  br label %loc_1101

loc_1101:                                           ; preds = %bb_swap, %loc_10E0
  %r8.after = phi i64 [ %r8.cur, %loc_10E0 ], [ %r8.new, %bb_swap ]
  %rdx.ph = phi i8* [ %rdx.cur, %loc_10E0 ], [ %rdx.cur, %bb_swap ]
  %rax.ph = phi i64 [ %rax.cur, %loc_10E0 ], [ %rax.cur, %bb_swap ]
  %rax.next = add i64 %rax.ph, 1
  %rdx.next = getelementptr inbounds i8, i8* %rdx.ph, i64 4
  %cmp_rax_rdi = icmp ne i64 %rdi.loop, %rax.next
  br i1 %cmp_rax_rdi, label %loc_10E0, label %bb_110E

bb_110E:                                            ; corresponds to 0x110e..0x111c sequence
  %is_zero = icmp eq i64 %r8.after, 0
  br i1 %is_zero, label %loc_111E, label %bb_1113

bb_1113:
  %is_one = icmp eq i64 %r8.after, 1
  br i1 %is_one, label %loc_111E, label %bb_1119

bb_1119:
  %r8.pass.110E = add i64 %r8.after, 0
  br label %loc_10D0

loc_111E:                                           ; preds = %bb_1113, %bb_110E
  %r12.end.i8 = bitcast i64* %var20.ptr to i8*
  br label %loc_1130

loc_1130:                                           ; preds = %loc_111E, %bb_1148
  %rbx.it = phi i8* [ %rbx.base.i8, %loc_111E ], [ %rbx.next, %bb_1148 ]
  %val.to.print.ptr = bitcast i8* %rbx.it to i32*
  %val.to.print = load i32, i32* %val.to.print.ptr, align 4
  %fmt.ptr.2004 = getelementptr inbounds [0 x i8], [0 x i8]* @unk_2004, i64 0, i64 0
  %rbx.next = getelementptr inbounds i8, i8* %rbx.it, i64 4
  %call.printf.loop = call i32 (i32, i8*, ...) @__printf_chk(i32 2, i8* %fmt.ptr.2004, i32 %val.to.print)
  %cmp.end = icmp ne i8* %r12.end.i8, %rbx.next
  br i1 %cmp.end, label %bb_1148, label %bb_114A

bb_1148:
  br label %loc_1130

bb_114A:
  %fmt.ptr.2008 = getelementptr inbounds [0 x i8], [0 x i8]* @unk_2008, i64 0, i64 0
  %call.printf.tail = call i32 (i32, i8*, ...) @__printf_chk(i32 2, i8* %fmt.ptr.2008)
  %saved.guard = load i64, i64* %var20.ptr, align 8
  %cur.guard = load i64, i64* @__stack_chk_guard, align 8
  %guard.ok = icmp eq i64 %saved.guard, %cur.guard
  br i1 %guard.ok, label %bb_116D, label %loc_1178

bb_116D:
  ret i32 0

loc_1178:                                           ; preds = %bb_114A
  call void @__stack_chk_fail()
  unreachable
}