; === ERROR LOG BEGIN [llvm-as] ===
; llvm-as-14: assembly parsed, but does not verify as correct!
; Instruction does not dominate all uses!
;   %dist.cur.ptr = getelementptr inbounds [7 x i32], [7 x i32]* %dist, i64 0, i64 %cur.node
;   %dist.cur2 = load i32, i32* %dist.cur.ptr, align 4
; Instruction does not dominate all uses!
;   %dist.cur.ptr = getelementptr inbounds [7 x i32], [7 x i32]* %dist, i64 0, i64 %cur.node
;   %dist.cur3 = load i32, i32* %dist.cur.ptr, align 4
; Instruction does not dominate all uses!
;   %dist.cur.ptr = getelementptr inbounds [7 x i32], [7 x i32]* %dist, i64 0, i64 %cur.node
;   %dist.cur4 = load i32, i32* %dist.cur.ptr, align 4
; Instruction does not dominate all uses!
;   %dist.cur.ptr = getelementptr inbounds [7 x i32], [7 x i32]* %dist, i64 0, i64 %cur.node
;   %dist.cur5 = load i32, i32* %dist.cur.ptr, align 4
; Instruction does not dominate all uses!
;   %dist.cur.ptr = getelementptr inbounds [7 x i32], [7 x i32]* %dist, i64 0, i64 %cur.node
;   %dist.cur6 = load i32, i32* %dist.cur.ptr, align 4
; Instruction does not dominate all uses!
;   %dist.cur.ptr = getelementptr inbounds [7 x i32], [7 x i32]* %dist, i64 0, i64 %cur.node
;   %dist.cur7 = load i32, i32* %dist.cur.ptr, align 4
; PHI nodes not grouped at top of basic block!
;   %rbx.next.out = phi i64 [ %rbx.next, %loc_12F8 ], [ %rbx.next, %bb_12f8_chk2 ], [ %rbx.next, %bb_12f8_then ]
; label %loc_1320
; PHI nodes not grouped at top of basic block!
;   %count = phi i64 [ %rsi.out, %bb_1329 ]
; label %bb_1329
; === ERROR LOG END ===

; ModuleID = 'recovered_main'
target triple = "x86_64-pc-linux-gnu"

@.str_bfs = private unnamed_addr constant [21 x i8] c"BFS order from %zu: \00", align 1
@.str_zus = private unnamed_addr constant [6 x i8] c"%zu%s\00", align 1
@.str_space = private unnamed_addr constant [2 x i8] c" \00", align 1
@.str_empty = private unnamed_addr constant [1 x i8] c"\00", align 1
@.str_nl = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@.str_dist = private unnamed_addr constant [23 x i8] c"dist(%zu -> %zu) = %d\0A\00", align 1

@__stack_chk_guard = external global i64

declare i8* @malloc(i64)
declare void @free(i8*)
declare i32 @__printf_chk(i32, i8*, ...)
declare void @__stack_chk_fail()

define i32 @main() local_unnamed_addr {
entry:
  ; stack protector prologue (load guard)
  %canary.slot = alloca i64, align 8
  %guard0 = load i64, i64* @__stack_chk_guard, align 8
  store i64 %guard0, i64* %canary.slot, align 8

  ; locals
  %adj = alloca [7 x [7 x i32]], align 16
  %dist = alloca [7 x i32], align 16
  %order = alloca [7 x i64], align 16
  %queue.ptr = alloca i8*, align 8

  ; memset adj to 0
  %adj.i8 = bitcast [7 x [7 x i32]]* %adj to i8*
  call void @llvm.memset.p0i8.i64(i8* %adj.i8, i8 0, i64 196, i1 false)

  ; initialize specific adjacency entries to 1 (matching stores at 0x1105..0x117d)
  ; index = row*7 + col
  ; [1][0] = 1 (index 7)
  %adj_10_ptr = getelementptr inbounds [7 x [7 x i32]], [7 x [7 x i32]]* %adj, i64 0, i64 1, i64 0
  store i32 1, i32* %adj_10_ptr, align 4
  ; [2][0] = 1 (index 14)
  %adj_20_ptr = getelementptr inbounds [7 x [7 x i32]], [7 x [7 x i32]]* %adj, i64 0, i64 2, i64 0
  store i32 1, i32* %adj_20_ptr, align 4
  ; [3][1] = 1 (index 22)
  %adj_31_ptr = getelementptr inbounds [7 x [7 x i32]], [7 x [7 x i32]]* %adj, i64 0, i64 3, i64 1
  store i32 1, i32* %adj_31_ptr, align 4
  ; [4][1] = 1 (index 29)
  %adj_41_ptr = getelementptr inbounds [7 x [7 x i32]], [7 x [7 x i32]]* %adj, i64 0, i64 4, i64 1
  store i32 1, i32* %adj_41_ptr, align 4
  ; [2][5] = 1 (index 19)
  %adj_25_ptr = getelementptr inbounds [7 x [7 x i32]], [7 x [7 x i32]]* %adj, i64 0, i64 2, i64 5
  store i32 1, i32* %adj_25_ptr, align 4
  ; [5][2] = 1 (index 37)
  %adj_52_ptr = getelementptr inbounds [7 x [7 x i32]], [7 x [7 x i32]]* %adj, i64 0, i64 5, i64 2
  store i32 1, i32* %adj_52_ptr, align 4
  ; [4][5] = 1 (index 33)
  %adj_45_ptr = getelementptr inbounds [7 x [7 x i32]], [7 x [7 x i32]]* %adj, i64 0, i64 4, i64 5
  store i32 1, i32* %adj_45_ptr, align 4
  ; [5][4] = 1 (index 39)
  %adj_54_ptr = getelementptr inbounds [7 x [7 x i32]], [7 x [7 x i32]]* %adj, i64 0, i64 5, i64 4
  store i32 1, i32* %adj_54_ptr, align 4
  ; [5][6] = 1 (index 41)
  %adj_56_ptr = getelementptr inbounds [7 x [7 x i32]], [7 x [7 x i32]]* %adj, i64 0, i64 5, i64 6
  store i32 1, i32* %adj_56_ptr, align 4
  ; [6][5] = 1 (index 47)
  %adj_65_ptr = getelementptr inbounds [7 x [7 x i32]], [7 x [7 x i32]]* %adj, i64 0, i64 6, i64 5
  store i32 1, i32* %adj_65_ptr, align 4

  ; initialize dist[0..6] = -1
  %dist_i8 = bitcast [7 x i32]* %dist to i8*
  call void @llvm.memset.p0i8.i64(i8* %dist_i8, i8 -1, i64 28, i1 false)

  ; allocate queue: malloc(0x38)
  %qraw = call i8* @malloc(i64 56)
  store i8* %qraw, i8** %queue.ptr, align 8
  %qnull = icmp eq i8* %qraw, null
  br i1 %qnull, label %loc_1414, label %after_malloc

after_malloc:                                      ; fallthrough from entry if malloc succeeded
  ; rdi = queue base, esi = 1, rbx = 0
  %q64 = bitcast i8* %qraw to i64*
  ; queue[0] = 0
  %q0 = getelementptr inbounds i64, i64* %q64, i64 0
  store i64 0, i64* %q0, align 8
  ; set dist[0] = 0
  %dist0ptr = getelementptr inbounds [7 x i32], [7 x i32]* %dist, i64 0, i64 0
  store i32 0, i32* %dist0ptr, align 4
  ; initial EAX-equivalent for first test = 0
  br label %loc_11D3

; 0x11c0
loc_11C0:                                           ; preds = %loc_1320
  ; compute eax = adj[row][0] for next iteration
  ; rbx current head index is incoming via PHI in loc_11D3 and updated to %rbx.next in that block
  ; Here, we recompute using current rbx (not yet incremented)
  %rbx.cur_for_11c0 = phi i64 [ %rbx.next.out, %loc_1320 ]
  %rsi.cur_for_11c0 = phi i64 [ %rsi.out, %loc_1320 ]
  %qbase.11c0 = load i8*, i8** %queue.ptr, align 8
  %q64.11c0 = bitcast i8* %qbase.11c0 to i64*
  %qdyn.ptr = getelementptr inbounds i64, i64* %q64.11c0, i64 %rbx.cur_for_11c0
  %node.for.next = load i64, i64* %qdyn.ptr, align 8
  ; rax = 7*rdx (node)
  %mul7.next = mul i64 %node.for.next, 7
  ; eax = adj[node][0]
  %adj_row0.base = getelementptr inbounds [7 x [7 x i32]], [7 x [7 x i32]]* %adj, i64 0, i64 %node.for.next, i64 0
  %eax.next = load i32, i32* %adj_row0.base, align 4
  br label %loc_11D3

; 0x11d3
loc_11D3:                                           ; preds = %after_malloc, %loc_11C0
  ; PHIs for rbx (head), rsi (tail), and eax(prev)
  %rbx.in = phi i64 [ 0, %after_malloc ], [ %rbx.cur_for_11c0, %loc_11C0 ]
  %rsi.in = phi i64 [ 1, %after_malloc ], [ %rsi.cur_for_11c0, %loc_11C0 ]
  %eax.prev = phi i32 [ 0, %after_malloc ], [ %eax.next, %loc_11C0 ]

  ; rbx = rbx + 1
  %rbx.next = add i64 %rbx.in, 1
  ; current node = queue[rbx-1]
  %qbase.11d3 = load i8*, i8** %queue.ptr, align 8
  %q64.11d3 = bitcast i8* %qbase.11d3 to i64*
  %idx.prev = add i64 %rbx.next, -1
  %qelem.ptr = getelementptr inbounds i64, i64* %q64.11d3, i64 %idx.prev
  %cur.node = load i64, i64* %qelem.ptr, align 8
  ; save order[rbx-1] = cur.node
  %order.store.ptr = getelementptr inbounds [7 x i64], [7 x i64]* %order, i64 0, i64 %idx.prev
  store i64 %cur.node, i64* %order.store.ptr, align 8

  ; test eax, eax  -> jz loc_1200
  %tst_eax_zero = icmp eq i32 %eax.prev, 0
  br i1 %tst_eax_zero, label %loc_1200, label %bb_11d3_chk1

bb_11d3_chk1:                                      ; preds = %loc_11D3
  ; cmp dword ptr [dist[0]], -1  -> jnz loc_1200
  %dist0.load = load i32, i32* %dist0ptr, align 4
  %dist0_ne_m1 = icmp ne i32 %dist0.load, -1
  br i1 %dist0_ne_m1, label %loc_1200, label %bb_11d3_then1

bb_11d3_then1:                                     ; preds = %bb_11d3_chk1
  ; eax = dist[cur.node]
  %dist.cur.ptr = getelementptr inbounds [7 x i32], [7 x i32]* %dist, i64 0, i64 %cur.node
  %dist.cur = load i32, i32* %dist.cur.ptr, align 4
  ; enqueue neighbor 0
  %rsi.enq0.next = add i64 %rsi.in, 1
  %qenq.ptr0 = getelementptr inbounds i64, i64* %q64.11d3, i64 %rsi.in
  store i64 0, i64* %qenq.ptr0, align 8
  ; dist[0] = dist[cur] + 1
  %dist0.new = add i32 %dist.cur, 1
  store i32 %dist0.new, i32* %dist0ptr, align 4
  br label %loc_1200

; 0x1200
loc_1200:                                           ; preds = %loc_11D3, %bb_11d3_chk1, %bb_11d3_then1
  ; PHI merge for rsi (tail)
  %rsi.1200 = phi i64 [ %rsi.in, %loc_11D3 ], [ %rsi.in, %bb_11d3_chk1 ], [ %rsi.enq0.next, %bb_11d3_then1 ]
  ; rcx = 7*cur.node
  %mul7.cur = mul i64 %cur.node, 7
  ; r11d = adj[cur.node][1]
  %adj_row1.base = getelementptr inbounds [7 x [7 x i32]], [7 x [7 x i32]]* %adj, i64 0, i64 %cur.node, i64 1
  %r11d = load i32, i32* %adj_row1.base, align 4
  ; test r11d, r11d -> jz loc_1240
  %r11_zero = icmp eq i32 %r11d, 0
  br i1 %r11_zero, label %loc_1240, label %bb_1200_chk2

bb_1200_chk2:                                      ; preds = %loc_1200
  ; cmp dist[1], -1 -> jnz loc_1240
  %dist1ptr = getelementptr inbounds [7 x i32], [7 x i32]* %dist, i64 0, i64 1
  %dist1 = load i32, i32* %dist1ptr, align 4
  %dist1_ne_m1 = icmp ne i32 %dist1, -1
  br i1 %dist1_ne_m1, label %loc_1240, label %bb_1200_then

bb_1200_then:                                      ; preds = %bb_1200_chk2
  ; enqueue neighbor 1
  %qenq.ptr1 = getelementptr inbounds i64, i64* %q64.11d3, i64 %rsi.1200
  store i64 1, i64* %qenq.ptr1, align 8
  %rsi.1200.enq = add i64 %rsi.1200, 1
  ; dist[1] = dist[cur] + 1
  %dist.cur2 = load i32, i32* %dist.cur.ptr, align 4
  %dist1.new = add i32 %dist.cur2, 1
  store i32 %dist1.new, i32* %dist1ptr, align 4
  br label %loc_1240

; 0x1240
loc_1240:                                           ; preds = %loc_1200, %bb_1200_chk2, %bb_1200_then
  %rsi.1240 = phi i64 [ %rsi.1200, %loc_1200 ], [ %rsi.1200, %bb_1200_chk2 ], [ %rsi.1200.enq, %bb_1200_then ]
  ; r10d = adj[cur.node][2]
  %adj_row2.base = getelementptr inbounds [7 x [7 x i32]], [7 x [7 x i32]]* %adj, i64 0, i64 %cur.node, i64 2
  %r10d = load i32, i32* %adj_row2.base, align 4
  ; test r10d -> jz loc_1270
  %r10_zero = icmp eq i32 %r10d, 0
  br i1 %r10_zero, label %loc_1270, label %bb_1240_chk2

bb_1240_chk2:                                      ; preds = %loc_1240
  ; cmp dist[2], -1 -> jnz loc_1270
  %dist2ptr = getelementptr inbounds [7 x i32], [7 x i32]* %dist, i64 0, i64 2
  %dist2 = load i32, i32* %dist2ptr, align 4
  %dist2_ne_m1 = icmp ne i32 %dist2, -1
  br i1 %dist2_ne_m1, label %loc_1270, label %bb_1240_then

bb_1240_then:                                      ; preds = %bb_1240_chk2
  ; enqueue neighbor 2
  %qenq.ptr2 = getelementptr inbounds i64, i64* %q64.11d3, i64 %rsi.1240
  store i64 2, i64* %qenq.ptr2, align 8
  %rsi.1240.enq = add i64 %rsi.1240, 1
  ; dist[2] = dist[cur] + 1
  %dist.cur3 = load i32, i32* %dist.cur.ptr, align 4
  %dist2.new = add i32 %dist.cur3, 1
  store i32 %dist2.new, i32* %dist2ptr, align 4
  br label %loc_1270

; 0x1270
loc_1270:                                           ; preds = %loc_1240, %bb_1240_chk2, %bb_1240_then
  %rsi.1270 = phi i64 [ %rsi.1240, %loc_1240 ], [ %rsi.1240, %bb_1240_chk2 ], [ %rsi.1240.enq, %bb_1240_then ]
  ; r9d = adj[cur.node][3]
  %adj_row3.base = getelementptr inbounds [7 x [7 x i32]], [7 x [7 x i32]]* %adj, i64 0, i64 %cur.node, i64 3
  %r9d = load i32, i32* %adj_row3.base, align 4
  ; test r9d -> jz loc_12A0
  %r9_zero = icmp eq i32 %r9d, 0
  br i1 %r9_zero, label %loc_12A0, label %bb_1270_chk2

bb_1270_chk2:                                      ; preds = %loc_1270
  ; cmp dist[3], -1 -> jnz loc_12A0
  %dist3ptr = getelementptr inbounds [7 x i32], [7 x i32]* %dist, i64 0, i64 3
  %dist3 = load i32, i32* %dist3ptr, align 4
  %dist3_ne_m1 = icmp ne i32 %dist3, -1
  br i1 %dist3_ne_m1, label %loc_12A0, label %bb_1270_then

bb_1270_then:                                      ; preds = %bb_1270_chk2
  ; enqueue neighbor 3
  %qenq.ptr3 = getelementptr inbounds i64, i64* %q64.11d3, i64 %rsi.1270
  store i64 3, i64* %qenq.ptr3, align 8
  %rsi.1270.enq = add i64 %rsi.1270, 1
  ; dist[3] = dist[cur] + 1
  %dist.cur4 = load i32, i32* %dist.cur.ptr, align 4
  %dist3.new = add i32 %dist.cur4, 1
  store i32 %dist3.new, i32* %dist3ptr, align 4
  br label %loc_12A0

; 0x12a0
loc_12A0:                                           ; preds = %loc_1270, %bb_1270_chk2, %bb_1270_then
  %rsi.12A0 = phi i64 [ %rsi.1270, %loc_1270 ], [ %rsi.1270, %bb_1270_chk2 ], [ %rsi.1270.enq, %bb_1270_then ]
  ; r8d = adj[cur.node][4]
  %adj_row4.base = getelementptr inbounds [7 x [7 x i32]], [7 x [7 x i32]]* %adj, i64 0, i64 %cur.node, i64 4
  %r8d = load i32, i32* %adj_row4.base, align 4
  ; test r8d -> jz loc_12D0
  %r8_zero = icmp eq i32 %r8d, 0
  br i1 %r8_zero, label %loc_12D0, label %bb_12a0_chk2

bb_12a0_chk2:                                      ; preds = %loc_12A0
  ; cmp dist[4], -1 -> jnz loc_12D0
  %dist4ptr = getelementptr inbounds [7 x i32], [7 x i32]* %dist, i64 0, i64 4
  %dist4 = load i32, i32* %dist4ptr, align 4
  %dist4_ne_m1 = icmp ne i32 %dist4, -1
  br i1 %dist4_ne_m1, label %loc_12D0, label %bb_12a0_then

bb_12a0_then:                                      ; preds = %bb_12a0_chk2
  ; enqueue neighbor 4
  %qenq.ptr4 = getelementptr inbounds i64, i64* %q64.11d3, i64 %rsi.12A0
  store i64 4, i64* %qenq.ptr4, align 8
  %rsi.12a0.enq = add i64 %rsi.12A0, 1
  ; dist[4] = dist[cur] + 1
  %dist.cur5 = load i32, i32* %dist.cur.ptr, align 4
  %dist4.new = add i32 %dist.cur5, 1
  store i32 %dist4.new, i32* %dist4ptr, align 4
  br label %loc_12D0

; 0x12d0
loc_12D0:                                           ; preds = %loc_12A0, %bb_12a0_chk2, %bb_12a0_then
  %rsi.12D0 = phi i64 [ %rsi.12A0, %loc_12A0 ], [ %rsi.12A0, %bb_12a0_chk2 ], [ %rsi.12a0.enq, %bb_12a0_then ]
  ; ecx = adj[cur.node][5]
  %adj_row5.base = getelementptr inbounds [7 x [7 x i32]], [7 x [7 x i32]]* %adj, i64 0, i64 %cur.node, i64 5
  %rcx5 = load i32, i32* %adj_row5.base, align 4
  ; test -> jz loc_12F8
  %rcx5_zero = icmp eq i32 %rcx5, 0
  br i1 %rcx5_zero, label %loc_12F8, label %bb_12d0_chk2

bb_12d0_chk2:                                      ; preds = %loc_12D0
  ; cmp dist[5], -1 -> jnz loc_12F8
  %dist5ptr = getelementptr inbounds [7 x i32], [7 x i32]* %dist, i64 0, i64 5
  %dist5 = load i32, i32* %dist5ptr, align 4
  %dist5_ne_m1 = icmp ne i32 %dist5, -1
  br i1 %dist5_ne_m1, label %loc_12F8, label %bb_12d0_then

bb_12d0_then:                                      ; preds = %bb_12d0_chk2
  ; enqueue neighbor 5
  %qenq.ptr5 = getelementptr inbounds i64, i64* %q64.11d3, i64 %rsi.12D0
  store i64 5, i64* %qenq.ptr5, align 8
  %rsi.12d0.enq = add i64 %rsi.12D0, 1
  ; dist[5] = dist[cur] + 1
  %dist.cur6 = load i32, i32* %dist.cur.ptr, align 4
  %dist5.new = add i32 %dist.cur6, 1
  store i32 %dist5.new, i32* %dist5ptr, align 4
  br label %loc_12F8

; 0x12f8
loc_12F8:                                           ; preds = %loc_12D0, %bb_12d0_chk2, %bb_12d0_then
  %rsi.12F8 = phi i64 [ %rsi.12D0, %loc_12D0 ], [ %rsi.12D0, %bb_12d0_chk2 ], [ %rsi.12d0.enq, %bb_12d0_then ]
  ; eax = adj[cur.node][6]
  %adj_row6.base = getelementptr inbounds [7 x [7 x i32]], [7 x [7 x i32]]* %adj, i64 0, i64 %cur.node, i64 6
  %eax6 = load i32, i32* %adj_row6.base, align 4
  ; test eax -> jz loc_1320
  %eax6_zero = icmp eq i32 %eax6, 0
  br i1 %eax6_zero, label %loc_1320, label %bb_12f8_chk2

bb_12f8_chk2:                                      ; preds = %loc_12F8
  ; cmp dist[6], -1 -> jnz loc_1320
  %dist6ptr = getelementptr inbounds [7 x i32], [7 x i32]* %dist, i64 0, i64 6
  %dist6 = load i32, i32* %dist6ptr, align 4
  %dist6_ne_m1 = icmp ne i32 %dist6, -1
  br i1 %dist6_ne_m1, label %loc_1320, label %bb_12f8_then

bb_12f8_then:                                      ; preds = %bb_12f8_chk2
  ; enqueue neighbor 6
  %qenq.ptr6 = getelementptr inbounds i64, i64* %q64.11d3, i64 %rsi.12F8
  store i64 6, i64* %qenq.ptr6, align 8
  %rsi.12f8.enq = add i64 %rsi.12F8, 1
  ; dist[6] = dist[cur] + 1
  %dist.cur7 = load i32, i32* %dist.cur.ptr, align 4
  %dist6.new = add i32 %dist.cur7, 1
  store i32 %dist6.new, i32* %dist6ptr, align 4
  br label %loc_1320

; 0x1320
loc_1320:                                           ; preds = %loc_12F8, %bb_12f8_chk2, %bb_12f8_then
  %rsi.out = phi i64 [ %rsi.12F8, %loc_12F8 ], [ %rsi.12F8, %bb_12f8_chk2 ], [ %rsi.12f8.enq, %bb_12f8_then ]
  ; cmp rbx.next, rsi.out  -> jb loc_11C0 else continue
  %cmp_rbx_rsi = icmp ult i64 %rbx.next, %rsi.out
  ; carry rbx.next to 11C0 PHI
  %rbx.next.out = phi i64 [ %rbx.next, %loc_12F8 ], [ %rbx.next, %bb_12f8_chk2 ], [ %rbx.next, %bb_12f8_then ]
  br i1 %cmp_rbx_rsi, label %loc_11C0, label %bb_1329

bb_1329:                                            ; corresponds to 0x1329 fallthrough after cmp (exit of BFS loop)
  ; free(queue)
  %qbase.free = load i8*, i8** %queue.ptr, align 8
  call void @free(i8* %qbase.free)
  ; printf header: __printf_chk(2, "BFS order from %zu: ", 0)
  %hdr.ptr = getelementptr inbounds [21 x i8], [21 x i8]* @.str_bfs, i64 0, i64 0
  %ret0 = call i32 (i32, i8*, ...) @__printf_chk(i32 2, i8* %hdr.ptr, i64 0)
  ; load first order element
  %first.elem.ptr = getelementptr inbounds [7 x i64], [7 x i64]* %order, i64 0, i64 0
  %first.elem = load i64, i64* %first.elem.ptr, align 8
  ; rbx == rsi? we need total count = rbx.next (equal to rsi.out)
  %count = phi i64 [ %rsi.out, %bb_1329 ]
  ; cmp rbx.next, 1 -> jnz loc_13DD else single
  %cmp_one = icmp ne i64 %count, 1
  br i1 %cmp_one, label %loc_13DD, label %loc_1360

; 0x13dd
loc_13DD:                                           ; preds = %bb_1329
  ; r12 = &order[count]
  %order.base = getelementptr inbounds [7 x i64], [7 x i64]* %order, i64 0, i64 0
  %order.end = getelementptr inbounds i64, i64* %order.base, i64 %count
  ; rbp = &order[1]
  %iter.ptr.init = getelementptr inbounds i64, i64* %order.base, i64 1
  br label %loc_13F0

; 0x13f0
loc_13F0:                                           ; preds = %loc_13DD, %bb_140a_back
  %iter.ptr = phi i64* [ %iter.ptr.init, %loc_13DD ], [ %iter.ptr.next, %bb_140a_back ]
  %last.val = phi i64 [ %first.elem, %loc_13DD ], [ %next.val, %bb_140a_back ]
  ; print previous element with space suffix: "%zu%s", last.val, " "
  %fmt_zus = getelementptr inbounds [6 x i8], [6 x i8]* @.str_zus, i64 0, i64 0
  %space.ptr = getelementptr inbounds [2 x i8], [2 x i8]* @.str_space, i64 0, i64 0
  %ret1 = call i32 (i32, i8*, ...) @__printf_chk(i32 2, i8* %fmt_zus, i64 %last.val, i8* %space.ptr)
  ; advance
  %iter.ptr.next = getelementptr inbounds i64, i64* %iter.ptr, i64 1
  ; next value to print = *iter.ptr
  %next.val = load i64, i64* %iter.ptr, align 8
  ; cmp rbp, r12 -> jnz loc_13F0 else jump 1360
  %cmp_end = icmp ne i64* %iter.ptr.next, %order.end
  br i1 %cmp_end, label %bb_140a_back, label %loc_1360

bb_140a_back:                                       ; pseudo block for 0x140a backedge to loc_13F0
  br label %loc_13F0

; 0x1360
loc_1360:                                           ; preds = %bb_1329, %loc_13F0
  %last.to.print = phi i64 [ %first.elem, %bb_1329 ], [ %next.val, %loc_13F0 ]
  ; print last element with empty suffix
  %fmt_zus2 = getelementptr inbounds [6 x i8], [6 x i8]* @.str_zus, i64 0, i64 0
  %empty.ptr = getelementptr inbounds [1 x i8], [1 x i8]* @.str_empty, i64 0, i64 0
  %ret2 = call i32 (i32, i8*, ...) @__printf_chk(i32 2, i8* %fmt_zus2, i64 %last.to.print, i8* %empty.ptr)
  br label %loc_1376

; 0x1414
loc_1414:                                           ; preds = %entry
  ; malloc failed: print header and go to newline
  %hdr.ptr.fail = getelementptr inbounds [21 x i8], [21 x i8]* @.str_bfs, i64 0, i64 0
  %retf = call i32 (i32, i8*, ...) @__printf_chk(i32 2, i8* %hdr.ptr.fail, i64 0)
  br label %loc_1376

; 0x1376
loc_1376:                                           ; preds = %loc_1360, %loc_1414
  ; print newline
  %nl.ptr = getelementptr inbounds [2 x i8], [2 x i8]* @.str_nl, i64 0, i64 0
  %ret3 = call i32 (i32, i8*, ...) @__printf_chk(i32 2, i8* %nl.ptr)
  ; prepare for distances printing
  br label %loc_1398

; 0x1398
loc_1398:                                           ; preds = %loc_1376, %loc_1398
  %i.idx = phi i64 [ 0, %loc_1376 ], [ %i.next, %loc_1398 ]
  ; r8d = dist[i]
  %dist.i.ptr = getelementptr inbounds [7 x i32], [7 x i32]* %dist, i64 0, i64 %i.idx
  %dist.i32 = load i32, i32* %dist.i.ptr, align 4
  ; print "dist(%zu -> %zu) = %d\n" with source 0, destination i, distance
  %fmt_dist = getelementptr inbounds [23 x i8], [23 x i8]* @.str_dist, i64 0, i64 0
  %ret4 = call i32 (i32, i8*, ...) @__printf_chk(i32 2, i8* %fmt_dist, i64 0, i64 %i.idx, i32 %dist.i32)
  ; i++
  %i.next = add i64 %i.idx, 1
  ; cmp rbx, 7 -> jnz loc_1398
  %cmp7 = icmp ne i64 %i.next, 7
  br i1 %cmp7, label %loc_1398, label %epilogue

; 0x142e
loc_142E:                                           ; preds = %epilogue
  call void @__stack_chk_fail()
  unreachable

epilogue:                                           ; corresponds to 0x13ba..13dc
  ; stack protector epilogue
  %guard.end = load i64, i64* @__stack_chk_guard, align 8
  %guard.init = load i64, i64* %canary.slot, align 8
  %guard.ok = icmp eq i64 %guard.end, %guard.init
  br i1 %guard.ok, label %retblock, label %loc_142E

retblock:
  ret i32 0
}

declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i1 immarg)