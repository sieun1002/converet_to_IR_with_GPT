; === ERROR LOG BEGIN [llvm-as] ===
; llvm-as-14: ../../llm_to_IR/gpt_api_error_analysis_add_cfg/O3_3/3/BFS_main1.ll:7:53: error: constant expression type mismatch: got type '[21 x i8]' but expected '[22 x i8]'
; @.str_bfs = private unnamed_addr constant [22 x i8] c"BFS order from %zu: \00", align 1
;                                                     ^
; === ERROR LOG END ===

; ModuleID = 'recovered_main'
source_filename = "recovered_main.ll"
target triple = "x86_64-pc-linux-gnu"

@qword_2038 = external global i32*          ; holds pointer to i32 table (loaded in code)

@.str_bfs = private unnamed_addr constant [22 x i8] c"BFS order from %zu: \00", align 1
@.str_zu_s = private unnamed_addr constant [6 x i8] c"%zu%s\00", align 1
@.str_space = private unnamed_addr constant [2 x i8] c" \00", align 1
@.str_nl = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@.str_dist = private unnamed_addr constant [23 x i8] c"dist(%zu -> %zu) = %d\0A\00", align 1

declare noalias i8* @malloc(i64) nounwind
declare void @free(i8*) nounwind
declare i32 @__printf_chk(i32, i8*, ...) nounwind
declare void @__stack_chk_fail() noreturn nounwind

define i32 @main() {
0x10c0:
  ; locals
  %guard = alloca i64, align 8
  %out_arr = alloca [7 x i64], align 16
  %dist = alloca [7 x i32], align 16
  %varF8 = alloca [49 x i32], align 16
  %adj_base.slot = alloca i32*, align 8
  %P.slot = alloca i64*, align 8

  ; "stack canary" simulate: save and later compare to itself
  store i64 0, i64* %guard, align 8

  ; zero varF8 (acts like the rep stosq region -> results in zeros for loads)
  ; initialize 49 ints to 0
  br label %init_f8.loop

init_f8.loop:
  %f8.idx = phi i32 [ 0, %0x10c0 ], [ %f8.idx.next, %init_f8.loop ]
  %f8.idx.next = add i32 %f8.idx, 1
  %f8.end = icmp eq i32 %f8.idx, 49
  br i1 %f8.end, label %init_dist, label %f8.body

f8.body:
  %f8.gep = getelementptr inbounds [49 x i32], [49 x i32]* %varF8, i64 0, i64 (0)
  %f8.gep.idx = getelementptr inbounds i32, i32* %f8.gep, i32 %f8.idx
  store i32 0, i32* %f8.gep.idx, align 4
  br label %init_f8.loop

init_dist:
  ; initialize dist[0..6] = -1
  br label %init_dist.loop

init_dist.loop:
  %d.idx = phi i32 [ 0, %init_dist ], [ %d.idx.next, %init_dist.loop ]
  %d.gep0 = getelementptr inbounds [7 x i32], [7 x i32]* %dist, i64 0, i64 0
  %d.elem = getelementptr inbounds i32, i32* %d.gep0, i32 %d.idx
  store i32 -1, i32* %d.elem, align 4
  %d.idx.next = add i32 %d.idx, 1
  %d.done = icmp eq i32 %d.idx, 7
  br i1 %d.done, label %after_init, label %init_dist.loop

after_init:
  ; dist[0] = 0
  %d0.ptr = getelementptr inbounds [7 x i32], [7 x i32]* %dist, i64 0, i64 0
  store i32 0, i32* %d0.ptr, align 4

  ; load adjacency base pointer from global qword_2038
  %adj.base = load i32*, i32** @qword_2038, align 8
  store i32* %adj.base, i32** %adj_base.slot, align 8

  ; malloc 0x38 (56) bytes
  %malloc.sz = zext i32 56 to i64
  %p.raw = call noalias i8* @malloc(i64 %malloc.sz)
  %p.null = icmp eq i8* %p.raw, null
  br i1 %p.null, label %loc_1414, label %0x1196

0x1196:
  ; setup initial state when malloc succeeded
  %p64 = bitcast i8* %p.raw to i64*
  store i64* %p64, i64** %P.slot, align 8
  ; r12 = &out_arr[0]
  ; rbx = 0; rsi = 1
  ; [p] = 0
  %p0.gep = getelementptr inbounds i64, i64* %p64, i64 0
  store i64 0, i64* %p0.gep, align 8
  br label %0x11B5

0x11B5:
  br label %0x11D3

0x11C0:
  ; rbx and rsi carried from loop backedge (0x1320)
  %rbx.carry = phi i64 [ %rbx.next.1320, %0x1320 ]
  %rsi.carry = phi i64 [ %rsi.next.1320, %0x1320 ]
  ; rdx = [P + rbx*8]
  %P.reload.11C0 = load i64*, i64** %P.slot, align 8
  %p.idx.ptr.11C0 = getelementptr inbounds i64, i64* %P.reload.11C0, i64 %rbx.carry
  %rdx.node.11C0 = load i64, i64* %p.idx.ptr.11C0, align 8
  ; idx7 = rdx*7
  %rdx.mul7.11C0 = mul i64 %rdx.node.11C0, 7
  ; eax_from_F8[idx7] (varF8 all zero)
  %f8.base.11C0 = getelementptr inbounds [49 x i32], [49 x i32]* %varF8, i64 0, i64 0
  %f8.elem.ptr.11C0 = getelementptr inbounds i32, i32* %f8.base.11C0, i64 %rdx.mul7.11C0
  %eax.from.11C0 = load i32, i32* %f8.elem.ptr.11C0, align 4
  br label %0x11D3

0x11D3:
  ; phi: rbx and rsi for loop body; EAX from prior calc (0 if from 11B5 first iteration)
  %rbx.curr = phi i64 [ 0, %0x11B5 ], [ %rbx.carry, %0x11C0 ]
  %rsi.curr = phi i64 [ 1, %0x11B5 ], [ %rsi.carry, %0x11C0 ]
  %eax.in = phi i32 [ 0, %0x11B5 ], [ %eax.from.11C0, %0x11C0 ]

  ; rbx = rbx + 1
  %rbx.next = add i64 %rbx.curr, 1

  ; rdx = [P + rbx*8 - 8] => [P + rbx.curr]
  %P.reload.11D3 = load i64*, i64** %P.slot, align 8
  %p.idx.ptr.11D3 = getelementptr inbounds i64, i64* %P.reload.11D3, i64 %rbx.curr
  %rdx.node = load i64, i64* %p.idx.ptr.11D3, align 8

  ; [out_arr + rbx*8 - 8] = rdx  (store the node into output stack array)
  %out.base = getelementptr inbounds [7 x i64], [7 x i64]* %out_arr, i64 0, i64 0
  %out.store.ptr = getelementptr inbounds i64, i64* %out.base, i64 %rbx.curr
  store i64 %rdx.node, i64* %out.store.ptr, align 8

  ; test eax, jz -> loc_1200 else -> process first neighbor at 0x11E5 then go to 0x1200
  %eax.iszero = icmp eq i32 %eax.in, 0
  br i1 %eax.iszero, label %0x1200, label %0x11E5

0x11E5:
  ; if dist[0] == -1 then enqueue 0 with distance dist[rdx]+1
  %d0.load = load i32, i32* %d0.ptr, align 4
  %d0.is.neg1 = icmp eq i32 %d0.load, -1
  br i1 %d0.is.neg1, label %neighbor0.do, label %neighbor0.join

neighbor0.do:
  ; ecx = dist[rdx]
  %dist.base.n0 = getelementptr inbounds [7 x i32], [7 x i32]* %dist, i64 0, i64 0
  %dist.src.ptr.n0 = getelementptr inbounds i32, i32* %dist.base.n0, i64 %rdx.node
  %src.val.n0 = load i32, i32* %dist.src.ptr.n0, align 4
  ; [P + rsi*8] = 0
  %P.reload.n0 = load i64*, i64** %P.slot, align 8
  %p.enqueue.ptr.n0 = getelementptr inbounds i64, i64* %P.reload.n0, i64 %rsi.curr
  store i64 0, i64* %p.enqueue.ptr.n0, align 8
  ; rsi++
  %rsi.inc.n0 = add i64 %rsi.curr, 1
  ; dist[0] = src+1
  %src.inc.n0 = add i32 %src.val.n0, 1
  store i32 %src.inc.n0, i32* %d0.ptr, align 4
  br label %neighbor0.join

neighbor0.join:
  ; rsi after optional increment
  %rsi.after.n0 = phi i64 [ %rsi.curr, %0x11E5 ], [ %rsi.inc.n0, %neighbor0.do ]
  br label %0x1200

0x1200:
  ; Compute idx for adjacency rows based on rdx.node
  %idx.mul7 = mul i64 %rdx.node, 7
  %idx.mul4 = mul i64 %idx.mul7, 4

  ; r11d = adj[idx+0]
  %adj.base.1200 = load i32*, i32** %adj_base.slot, align 8
  %adj.ptr.0 = getelementptr inbounds i32, i32* %adj.base.1200, i64 %idx.mul7
  %r11d = load i32, i32* %adj.ptr.0, align 4

  ; test r11d, jz loc_1240; else if dist[1]==-1 then enqueue 1
  %r11.zero = icmp eq i32 %r11d, 0
  br i1 %r11.zero, label %0x1240, label %neighbor1.check

neighbor1.check:
  %d1.ptr = getelementptr inbounds [7 x i32], [7 x i32]* %dist, i64 0, i64 1
  %d1.load = load i32, i32* %d1.ptr, align 4
  %d1.neg1 = icmp eq i32 %d1.load, -1
  br i1 %d1.neg1, label %neighbor1.do, label %0x1240

neighbor1.do:
  ; ecx = dist[rdx]
  %dist.base.n1 = getelementptr inbounds [7 x i32], [7 x i32]* %dist, i64 0, i64 0
  %dist.src.ptr.n1 = getelementptr inbounds i32, i32* %dist.base.n1, i64 %rdx.node
  %src.val.n1 = load i32, i32* %dist.src.ptr.n1, align 4
  ; [P + rsi*8] = 1
  %P.reload.n1 = load i64*, i64** %P.slot, align 8
  %p.enqueue.ptr.n1 = getelementptr inbounds i64, i64* %P.reload.n1, i64 %rsi.after.n0
  store i64 1, i64* %p.enqueue.ptr.n1, align 8
  ; rsi++
  %rsi.inc.n1 = add i64 %rsi.after.n0, 1
  ; dist[1] = src+1
  %src.inc.n1 = add i32 %src.val.n1, 1
  store i32 %src.inc.n1, i32* %d1.ptr, align 4
  br label %0x1240

0x1240:
  ; phi rsi from previous steps
  %rsi.in.1240 = phi i64 [ %rsi.after.n0, %0x1200 ], [ %rsi.after.n0, %neighbor1.check ], [ %rsi.inc.n1, %neighbor1.do ]

  ; r10d = adj[idx+1]
  %adj.ptr.1 = getelementptr inbounds i32, i32* %adj.base.1200, i64 add (i64 %idx.mul7, i64 1)
  %r10d = load i32, i32* %adj.ptr.1, align 4
  %r10.zero = icmp eq i32 %r10d, 0
  br i1 %r10.zero, label %0x1270, label %neighbor2.check

neighbor2.check:
  %d2.ptr = getelementptr inbounds [7 x i32], [7 x i32]* %dist, i64 0, i64 2
  %d2.load = load i32, i32* %d2.ptr, align 4
  %d2.neg1 = icmp eq i32 %d2.load, -1
  br i1 %d2.neg1, label %neighbor2.do, label %0x1270

neighbor2.do:
  %dist.base.n2 = getelementptr inbounds [7 x i32], [7 x i32]* %dist, i64 0, i64 0
  %dist.src.ptr.n2 = getelementptr inbounds i32, i32* %dist.base.n2, i64 %rdx.node
  %src.val.n2 = load i32, i32* %dist.src.ptr.n2, align 4
  %P.reload.n2 = load i64*, i64** %P.slot, align 8
  %p.enqueue.ptr.n2 = getelementptr inbounds i64, i64* %P.reload.n2, i64 %rsi.in.1240
  store i64 2, i64* %p.enqueue.ptr.n2, align 8
  %rsi.inc.n2 = add i64 %rsi.in.1240, 1
  %src.inc.n2 = add i32 %src.val.n2, 1
  store i32 %src.inc.n2, i32* %d2.ptr, align 4
  br label %0x1270

0x1270:
  %rsi.in.1270 = phi i64 [ %rsi.in.1240, %0x1240 ], [ %rsi.inc.n2, %neighbor2.do ], [ %rsi.in.1240, %neighbor2.check ]

  ; r9d = adj[idx+2]
  %adj.ptr.2 = getelementptr inbounds i32, i32* %adj.base.1200, i64 add (i64 %idx.mul7, i64 2)
  %r9d = load i32, i32* %adj.ptr.2, align 4
  %r9.zero = icmp eq i32 %r9d, 0
  br i1 %r9.zero, label %0x12A0, label %neighbor3.check

neighbor3.check:
  %d3.ptr = getelementptr inbounds [7 x i32], [7 x i32]* %dist, i64 0, i64 3
  %d3.load = load i32, i32* %d3.ptr, align 4
  %d3.neg1 = icmp eq i32 %d3.load, -1
  br i1 %d3.neg1, label %neighbor3.do, label %0x12A0

neighbor3.do:
  %dist.base.n3 = getelementptr inbounds [7 x i32], [7 x i32]* %dist, i64 0, i64 0
  %dist.src.ptr.n3 = getelementptr inbounds i32, i32* %dist.base.n3, i64 %rdx.node
  %src.val.n3 = load i32, i32* %dist.src.ptr.n3, align 4
  %P.reload.n3 = load i64*, i64** %P.slot, align 8
  %p.enqueue.ptr.n3 = getelementptr inbounds i64, i64* %P.reload.n3, i64 %rsi.in.1270
  store i64 3, i64* %p.enqueue.ptr.n3, align 8
  %rsi.inc.n3 = add i64 %rsi.in.1270, 1
  %src.inc.n3 = add i32 %src.val.n3, 1
  store i32 %src.inc.n3, i32* %d3.ptr, align 4
  br label %0x12A0

0x12A0:
  %rsi.in.12A0 = phi i64 [ %rsi.in.1270, %0x1270 ], [ %rsi.inc.n3, %neighbor3.do ], [ %rsi.in.1270, %neighbor3.check ]

  ; r8d = adj[idx+3]
  %adj.ptr.3 = getelementptr inbounds i32, i32* %adj.base.1200, i64 add (i64 %idx.mul7, i64 3)
  %r8d = load i32, i32* %adj.ptr.3, align 4
  %r8.zero = icmp eq i32 %r8d, 0
  br i1 %r8.zero, label %0x12D0, label %neighbor4.check

neighbor4.check:
  %d4.ptr = getelementptr inbounds [7 x i32], [7 x i32]* %dist, i64 0, i64 4
  %d4.load = load i32, i32* %d4.ptr, align 4
  %d4.neg1 = icmp eq i32 %d4.load, -1
  br i1 %d4.neg1, label %neighbor4.do, label %0x12D0

neighbor4.do:
  %dist.base.n4 = getelementptr inbounds [7 x i32], [7 x i32]* %dist, i64 0, i64 0
  %dist.src.ptr.n4 = getelementptr inbounds i32, i32* %dist.base.n4, i64 %rdx.node
  %src.val.n4 = load i32, i32* %dist.src.ptr.n4, align 4
  %P.reload.n4 = load i64*, i64** %P.slot, align 8
  %p.enqueue.ptr.n4 = getelementptr inbounds i64, i64* %P.reload.n4, i64 %rsi.in.12A0
  store i64 4, i64* %p.enqueue.ptr.n4, align 8
  %rsi.inc.n4 = add i64 %rsi.in.12A0, 1
  %src.inc.n4 = add i32 %src.val.n4, 1
  store i32 %src.inc.n4, i32* %d4.ptr, align 4
  br label %0x12D0

0x12D0:
  %rsi.in.12D0 = phi i64 [ %rsi.in.12A0, %0x12A0 ], [ %rsi.inc.n4, %neighbor4.do ], [ %rsi.in.12A0, %neighbor4.check ]

  ; ecx = adj[idx+4]
  %adj.ptr.4 = getelementptr inbounds i32, i32* %adj.base.1200, i64 add (i64 %idx.mul7, i64 4)
  %ecx.adj = load i32, i32* %adj.ptr.4, align 4
  %ecx.zero = icmp eq i32 %ecx.adj, 0
  br i1 %ecx.zero, label %0x12F8, label %neighbor5.check

neighbor5.check:
  %d5.ptr = getelementptr inbounds [7 x i32], [7 x i32]* %dist, i64 0, i64 5
  %d5.load = load i32, i32* %d5.ptr, align 4
  %d5.neg1 = icmp eq i32 %d5.load, -1
  br i1 %d5.neg1, label %neighbor5.do, label %0x12F8

neighbor5.do:
  %dist.base.n5 = getelementptr inbounds [7 x i32], [7 x i32]* %dist, i64 0, i64 0
  %dist.src.ptr.n5 = getelementptr inbounds i32, i32* %dist.base.n5, i64 %rdx.node
  %src.val.n5 = load i32, i32* %dist.src.ptr.n5, align 4
  %P.reload.n5 = load i64*, i64** %P.slot, align 8
  %p.enqueue.ptr.n5 = getelementptr inbounds i64, i64* %P.reload.n5, i64 %rsi.in.12D0
  store i64 5, i64* %p.enqueue.ptr.n5, align 8
  %rsi.inc.n5 = add i64 %rsi.in.12D0, 1
  %src.inc.n5 = add i32 %src.val.n5, 1
  store i32 %src.inc.n5, i32* %d5.ptr, align 4
  br label %0x12F8

0x12F8:
  %rsi.in.12F8 = phi i64 [ %rsi.in.12D0, %0x12D0 ], [ %rsi.inc.n5, %neighbor5.do ], [ %rsi.in.12D0, %neighbor5.check ]

  ; eax = adj[idx+5]
  %adj.ptr.5 = getelementptr inbounds i32, i32* %adj.base.1200, i64 add (i64 %idx.mul7, i64 5)
  %eax.adj = load i32, i32* %adj.ptr.5, align 4
  %eax.zero2 = icmp eq i32 %eax.adj, 0
  br i1 %eax.zero2, label %0x1320, label %neighbor6.check

neighbor6.check:
  %d6.ptr = getelementptr inbounds [7 x i32], [7 x i32]* %dist, i64 0, i64 6
  %d6.load = load i32, i32* %d6.ptr, align 4
  %d6.neg1 = icmp eq i32 %d6.load, -1
  br i1 %d6.neg1, label %neighbor6.do, label %0x1320

neighbor6.do:
  %dist.base.n6 = getelementptr inbounds [7 x i32], [7 x i32]* %dist, i64 0, i64 0
  %dist.src.ptr.n6 = getelementptr inbounds i32, i32* %dist.base.n6, i64 %rdx.node
  %src.val.n6 = load i32, i32* %dist.src.ptr.n6, align 4
  %P.reload.n6 = load i64*, i64** %P.slot, align 8
  %p.enqueue.ptr.n6 = getelementptr inbounds i64, i64* %P.reload.n6, i64 %rsi.in.12F8
  store i64 6, i64* %p.enqueue.ptr.n6, align 8
  %rsi.inc.n6 = add i64 %rsi.in.12F8, 1
  %src.inc.n6 = add i32 %src.val.n6, 1
  store i32 %src.inc.n6, i32* %d6.ptr, align 4
  br label %0x1320

0x1320:
  ; select rsi after last neighbor
  %rsi.next.1320 = phi i64 [ %rsi.in.12F8, %0x12F8 ], [ %rsi.inc.n6, %neighbor6.do ], [ %rsi.in.12F8, %neighbor6.check ]
  ; compare rbx.next and rsi to loop
  %rbx.next.1320 = phi i64 [ %rbx.next, %0x12F8 ], [ %rbx.next, %neighbor6.do ], [ %rbx.next, %neighbor6.check ]
  %cmp.jb = icmp ult i64 %rbx.next.1320, %rsi.next.1320
  br i1 %cmp.jb, label %0x11C0, label %0x1329

0x1329:
  ; free(P)
  %P.tofree = load i64*, i64** %P.slot, align 8
  %P.tofree.i8 = bitcast i64* %P.tofree to i8*
  call void @free(i8* %P.tofree.i8)
  ; print "BFS order from %zu: " with start 0
  %fmt.bfs.ptr = getelementptr inbounds [22 x i8], [22 x i8]* @.str_bfs, i64 0, i64 0
  %call.printf.hdr = call i32 (i32, i8*, ...) @__printf_chk(i32 2, i8* %fmt.bfs.ptr, i64 0)
  ; prepare for printing the order
  br label %0x134a

0x134a:
  ; load first element of out_arr (rdx)
  %out.base.134a = getelementptr inbounds [7 x i64], [7 x i64]* %out_arr, i64 0, i64 0
  %first.elem = load i64, i64* %out.base.134a, align 8
  ; rbx.final = rbx.next.1320
  %rbx.final = phi i64 [ %rbx.next.1320, %0x1329 ]
  ; if rbx != 1 -> loc_13DD else -> loc_1360
  %cmp.rbx1 = icmp ne i64 %rbx.final, 1
  br i1 %cmp.rbx1, label %0x13DD, label %0x1360

0x1360:
  ; print single (or last) element with suffix ""
  %fmt.zu.s = getelementptr inbounds [6 x i8], [6 x i8]* @.str_zu_s, i64 0, i64 0
  %empty.ptr = getelementptr inbounds [23 x i8], [23 x i8]* @.str_dist, i64 0, i64 22
  ; but assembly uses aDistZuZuD+16h (""); we provide empty string via "" derived pointer
  %empty.str = getelementptr inbounds [2 x i8], [2 x i8]* @.str_nl, i64 0, i64 1
  %call.print.single = call i32 (i32, i8*, ...) @__printf_chk(i32 2, i8* %fmt.zu.s, i64 %first.elem, i8* getelementptr inbounds ([1 x i8], [1 x i8]* bitcast (i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str_nl, i64 0, i64 1) to [1 x i8]*), i64 0, i64 0))
  br label %0x1376

0x1376:
  ; print newline
  %nl.ptr = getelementptr inbounds [2 x i8], [2 x i8]* @.str_nl, i64 0, i64 0
  %call.nl = call i32 (i32, i8*, ...) @__printf_chk(i32 2, i8* %nl.ptr)
  ; print distances loop: rbx = 0
  br label %0x1398

0x1398:
  ; loop over 0..6
  %dist.idx = phi i64 [ 0, %0x1376 ], [ %dist.idx.next, %0x13B4 ]
  ; load dist[dist.idx]
  %dist.base.loop = getelementptr inbounds [7 x i32], [7 x i32]* %dist, i64 0, i64 0
  %dist.ptr.i = getelementptr inbounds i32, i32* %dist.base.loop, i64 %dist.idx
  %dist.val.i32 = load i32, i32* %dist.ptr.i, align 4
  ; print "dist(0 -> idx) = val"
  %fmt.dist.ptr = getelementptr inbounds [23 x i8], [23 x i8]* @.str_dist, i64 0, i64 0
  %call.dist = call i32 (i32, i8*, ...) @__printf_chk(i32 2, i8* %fmt.dist.ptr, i64 0, i64 %dist.idx, i32 %dist.val.i32)
  ; increment
  %dist.idx.next = add i64 %dist.idx, 1
  br label %0x13B4

0x13B4:
  %cmp.end = icmp ne i64 %dist.idx.next, 7
  br i1 %cmp.end, label %0x1398, label %0x13BA

0x13BA:
  ; stack canary check (simulate by comparing guard with itself, preserves CFG shape)
  %canary.saved = load i64, i64* %guard, align 8
  %canary.curr = load i64, i64* %guard, align 8
  %canary.diff = icmp ne i64 %canary.saved, %canary.curr
  br i1 %canary.diff, label %0x142E, label %epilogue

epilogue:
  ret i32 0

0x13DD:
  ; print multiple elements: prepare pointers
  ; r12 = &out_arr[rbx.final]
  %out.base.13DD = getelementptr inbounds [7 x i64], [7 x i64]* %out_arr, i64 0, i64 0
  %out.end.ptr = getelementptr inbounds i64, i64* %out.base.13DD, i64 %rbx.final
  ; rbp = &out_arr[1]
  %out.iter.ptr = getelementptr inbounds i64, i64* %out.base.13DD, i64 1
  ; rdx current = out_arr[0] already in %first.elem
  br label %0x13F0

0x13F0:
  ; print current rdx with " "
  %fmt.zu.s.loop = getelementptr inbounds [6 x i8], [6 x i8]* @.str_zu_s, i64 0, i64 0
  %space.ptr = getelementptr inbounds [2 x i8], [2 x i8]* @.str_space, i64 0, i64 0
  %call.loop.print = call i32 (i32, i8*, ...) @__printf_chk(i32 2, i8* %fmt.zu.s.loop, i64 %first.elem, i8* %space.ptr)
  ; advance rbp and load next rdx
  %next.elem.ptr = getelementptr inbounds i64, i64* %out.iter.ptr, i64 0
  %next.elem = load i64, i64* %next.elem.ptr, align 8
  ; compare rbp to r12 end
  %done.loop = icmp eq i64* %out.iter.ptr, %out.end.ptr
  ; increment iter pointer
  %out.iter.ptr.next = getelementptr inbounds i64, i64* %out.iter.ptr, i64 1
  ; carry current element in %first.elem variable through phi
  br i1 %done.loop, label %0x1360, label %0x13F0.latch

0x13F0.latch:
  ; update carried values and loop
  %first.elem.phi = phi i64 [ %next.elem, %0x13F0 ]
  %out.iter.ptr.phi = phi i64* [ %out.iter.ptr.next, %0x13F0 ]
  ; backedge uses updated values
  br label %0x13F0

0x1414:
  ; malloc failed: print header then jump to print newline and distances
  %fmt.bfs.ptr.fail = getelementptr inbounds [22 x i8], [22 x i8]* @.str_bfs, i64 0, i64 0
  %call.printf.hdr.fail = call i32 (i32, i8*, ...) @__printf_chk(i32 2, i8* %fmt.bfs.ptr.fail, i64 0)
  br label %0x1376

0x142E:
  call void @__stack_chk_fail()
  unreachable
}