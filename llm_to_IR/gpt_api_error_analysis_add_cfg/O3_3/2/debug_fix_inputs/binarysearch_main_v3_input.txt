; === ERROR LOG BEGIN [llvm-as] ===
; llvm-as-14: ../../llm_to_IR/gpt_api_error_analysis_add_cfg/O3_3/2/binarysearch_main2.ll:109:14: error: found end of file when expecting more instructions
;   unreachable
;              ^
; === ERROR LOG END ===

; ModuleID = 'recovered.ll'
target triple = "x86_64-pc-linux-gnu"

@xmmword_2030 = internal constant <4 x i32> <i32 -10, i32 -3, i32 0, i32 2>, align 16
@xmmword_2040 = internal constant <4 x i32> <i32 5, i32 7, i32 9, i32 11>, align 16
@qword_2050   = internal constant i64 51539607555, align 8
@.str_index   = internal constant [21 x i8] c"key %d -> index %ld\0A\00", align 1
@.str_notfound = internal constant [21 x i8] c"key %d -> not found\0A\00", align 1
@__stack_chk_guard = external global i64

declare i32 @___printf_chk(i32, i8*, ...)
declare void @___stack_chk_fail() noreturn

define i32 @main() {
entry_1080:
  %arr = alloca [9 x i32], align 16
  %keys = alloca [3 x i32], align 16
  %canary.slot = alloca i64, align 8
  %guard.init = load i64, i64* @__stack_chk_guard, align 8
  store i64 %guard.init, i64* %canary.slot, align 8
  %arr.vec0.ptr = bitcast [9 x i32]* %arr to <4 x i32>*
  %v0 = load <4 x i32>, <4 x i32>* @xmmword_2030, align 16
  store <4 x i32> %v0, <4 x i32>* %arr.vec0.ptr, align 16
  %arr4.i32 = getelementptr inbounds [9 x i32], [9 x i32]* %arr, i64 0, i64 4
  %arr.vec1.ptr = bitcast i32* %arr4.i32 to <4 x i32>*
  %v1 = load <4 x i32>, <4 x i32>* @xmmword_2040, align 16
  store <4 x i32> %v1, <4 x i32>* %arr.vec1.ptr, align 16
  %arr8 = getelementptr inbounds [9 x i32], [9 x i32]* %arr, i64 0, i64 8
  store i32 12, i32* %arr8, align 4
  %q = load i64, i64* @qword_2050, align 8
  %key0.tr = trunc i64 %q to i32
  %q.shr = lshr i64 %q, 32
  %key1.tr = trunc i64 %q.shr to i32
  %keys0 = getelementptr inbounds [3 x i32], [3 x i32]* %keys, i64 0, i64 0
  store i32 %key0.tr, i32* %keys0, align 4
  %keys1 = getelementptr inbounds [3 x i32], [3 x i32]* %keys, i64 0, i64 1
  store i32 %key1.tr, i32* %keys1, align 4
  %keys2 = getelementptr inbounds [3 x i32], [3 x i32]* %keys, i64 0, i64 2
  store i32 -5, i32* %keys2, align 4
  %r12.init = bitcast [3 x i32]* %keys to i32*
  %rbx.end = getelementptr inbounds i32, i32* %r12.init, i64 3
  br label %loc_10E0

loc_10E0:
  %r12.phi = phi i32* [ %r12.init, %entry_1080 ], [ %r12.next, %loc_1127 ]
  %key.cur = load i32, i32* %r12.phi, align 4
  %rdx.init = zext i32 9 to i64
  %rcx.init = zext i32 0 to i64
  br label %loc_1105

loc_10F0:
  %rdx.diff = sub i64 %rdx.phi, %rcx.phi
  %rdx.half = lshr i64 %rdx.diff, 1
  %rax.mid = add i64 %rdx.half, %rcx.phi
  %arr.base = getelementptr inbounds [9 x i32], [9 x i32]* %arr, i64 0, i64 0
  %elem.ptr = getelementptr inbounds i32, i32* %arr.base, i64 %rax.mid
  %elem.val = load i32, i32* %elem.ptr, align 4
  %cmp.jg = icmp sgt i32 %key.phi, %elem.val
  br i1 %cmp.jg, label %loc_1150, label %loc_1105

loc_1105:
  %rcx.phi = phi i64 [ %rcx.init, %loc_10E0 ], [ %rcx.phi, %loc_10F0 ], [ %rcx.next, %loc_1150 ]
  %rdx.phi = phi i64 [ %rdx.init, %loc_10E0 ], [ %rax.mid, %loc_10F0 ], [ %rdx.phi, %loc_1150 ]
  %key.phi = phi i32 [ %key.cur, %loc_10E0 ], [ %key.phi, %loc_10F0 ], [ %key.phi, %loc_1150 ]
  %cmp.jb = icmp ult i64 %rcx.phi, %rdx.phi
  br i1 %cmp.jb, label %loc_10F0, label %bb_110A

bb_110A:
  %cmp.ja = icmp ugt i64 %rcx.phi, 8
  br i1 %cmp.ja, label %loc_1156, label %bb_1110

bb_1110:
  %arr.base2 = getelementptr inbounds [9 x i32], [9 x i32]* %arr, i64 0, i64 0
  %elem.rcx.ptr = getelementptr inbounds i32, i32* %arr.base2, i64 %rcx.phi
  %elem.rcx.val = load i32, i32* %elem.rcx.ptr, align 4
  %cmp.jnz = icmp ne i32 %key.phi, %elem.rcx.val
  br i1 %cmp.jnz, label %loc_1156, label %bb_1118

bb_1118:
  %fmt.idx.ptr = getelementptr inbounds [21 x i8], [21 x i8]* @.str_index, i64 0, i64 0
  %call.ok = call i32 (i32, i8*, ...) @___printf_chk(i32 2, i8* %fmt.idx.ptr, i32 %key.phi, i64 %rcx.phi)
  br label %loc_1127

loc_1127:
  %r12.next = getelementptr inbounds i32, i32* %r12.phi, i64 1
  %cmp.r12 = icmp ne i32* %rbx.end, %r12.next
  br i1 %cmp.r12, label %loc_10E0, label %bb_1130

bb_1130:
  %guard.saved = load i64, i64* %canary.slot, align 8
  %guard.now = load i64, i64* @__stack_chk_guard, align 8
  %guard.bad = icmp ne i64 %guard.saved, %guard.now
  br i1 %guard.bad, label %loc_116B, label %loc_1140

loc_1140:
  ret i32 0

loc_1150:
  %rcx.next = add i64 %rax.mid, 1
  br label %loc_1105

loc_1156:
  %fmt.nf.ptr = getelementptr inbounds [21 x i8], [21 x i8]* @.str_notfound, i64 0, i64 0
  %call.nf = call i32 (i32, i8*, ...) @___printf_chk(i32 2, i8* %fmt.nf.ptr, i32 %key.phi)
  br label %loc_1127

loc_116B:
  call void @___stack_chk_fail()
  unreachable