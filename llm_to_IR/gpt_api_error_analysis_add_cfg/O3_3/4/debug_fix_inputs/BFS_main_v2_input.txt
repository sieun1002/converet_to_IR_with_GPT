; === ERROR LOG BEGIN [llvm-as] ===
; llvm-as-14: ../../llm_to_IR/gpt_api_error_analysis_add_cfg/O3_3/4/BFS_main1.ll:308:3: error: multiple definition of local value named 'rbx.cur.ph2'
;   %rbx.cur.ph2 = phi i64 [ %rbx.next, %loc_1200 ], [ %rbx.next, %loc_1224_then ], [ %rbx.next, %loc_11E5_body ], [ %rbx.next, %loc_1240 ], [ %rbx.next, %loc_1251_then ], [ %rbx.next, %loc_1251_body ], [ %rbx.next, %loc_1270 ], [ %rbx.next, %loc_1281_then ], [ %rbx.next, %loc_1281_body ], [ %rbx.next, %loc_12A0 ], [ %rbx.next, %loc_12B1_then ], [ %rbx.next, %loc_12B1_body ], [ %rbx.next, %loc_12D0 ], [ %rbx.next, %loc_12DF_then ], [ %rbx.next, %loc_12DF_body ], [ %rbx.next, %loc_12F8 ], [ %rbx.next, %loc_1307_then ], [ %rbx.next, %loc_1307_body ]
;   ^
; === ERROR LOG END ===

; ModuleID = 'recovered_main'
target triple = "x86_64-pc-linux-gnu"

@__stack_chk_guard = external global i64
@qword_2038 = external global i64

@.str_bfs = private unnamed_addr constant [21 x i8] c"BFS order from %zu: \00", align 1
@.str_zu_s = private unnamed_addr constant [6 x i8] c"%zu%s\00", align 1
@.str_dist = private unnamed_addr constant [23 x i8] c"dist(%zu -> %zu) = %d\0A\00", align 1

declare i8* @_malloc(i64 noundef)
declare void @_free(i8* noundef)
declare i32 @___printf_chk(i32 noundef, i8* noundef, ...)
declare void @___stack_chk_fail()

define i32 @main() local_unnamed_addr {
loc_10c0:
  ; stack locals
  %varF8 = alloca [192 x i8], align 16            ; corresponds to region around var_F8..var_3C
  %var158 = alloca [4 x i32], align 16            ; corresponds to dwords at var_158, +4, +8, +0xC
  %order = alloca [7 x i64], align 16             ; corresponds to qwords at var_138..var_110
  %var148 = alloca i32, align 4
  %var144 = alloca i32, align 4
  %var140 = alloca i32, align 4
  %canary.save = alloca i64, align 8

  ; load stack guard
  %guard0 = load i64, i64* @__stack_chk_guard, align 8
  store i64 %guard0, i64* %canary.save, align 8

  ; zero memory region like rep stosq over 0x18 qwords starting at var_F8
  %varF8.p0 = getelementptr inbounds [192 x i8], [192 x i8]* %varF8, i64 0, i64 0
  call void @llvm.memset.p0i8.i64(i8* noundef %varF8.p0, i8 0, i64 192, i1 false)

  ; initialize distances array (var_158 block) to zero
  %var158.p0 = getelementptr inbounds [4 x i32], [4 x i32]* %var158, i64 0, i64 0
  store i32 0, i32* %var158.p0, align 16
  %var158.p1 = getelementptr inbounds i32, i32* %var158.p0, i64 1
  store i32 0, i32* %var158.p1, align 4
  %var158.p2 = getelementptr inbounds i32, i32* %var158.p0, i64 2
  store i32 0, i32* %var158.p2, align 8
  %var158.p3 = getelementptr inbounds i32, i32* %var158.p0, i64 3
  store i32 0, i32* %var158.p3, align 4

  ; clear order[0] (will be set anyway)
  %order.base = getelementptr inbounds [7 x i64], [7 x i64]* %order, i64 0, i64 0
  store i64 0, i64* %order.base, align 16

  ; malloc 0x38 bytes
  %m = call i8* @_malloc(i64 noundef 56)
  %m.isnull = icmp eq i8* %m, null
  br i1 %m.isnull, label %loc_1414, label %loc_after_malloc

loc_after_malloc:
  ; setup after successful malloc
  %arr64 = bitcast i8* %m to i64*
  store i64 0, i64* %arr64, align 8                       ; qword ptr [rdi] = 0
  ; rbx <- 0, rsi <- 1, r12 <- &order[0], eax <- 0, [var_158] already 0
  %order.base.i8 = bitcast i64* %order.base to i8*
  br label %loc_11D3

; 0x11C0
loc_11C0:
  ; PHIs for loop-carried state on backedge
  %rdi.ptr.ph = phi i8* [ %m, %loc_11D3 ], [ %rdi.ptr.ph2, %loc_1320 ]
  %rbx.cur.ph = phi i64 [ %rbx.next, %loc_11D3 ], [ %rbx.cur.ph2, %loc_1320 ]
  %rsi.cur.ph = phi i64 [ %rsi.cur, %loc_11D3 ], [ %rsi.cur.ph2, %loc_1320 ]
  %r12.base.ph = phi i8* [ %order.base.i8, %loc_11D3 ], [ %r12.base.ph2, %loc_1320 ]

  ; rdx = [rdi + rbx*8]
  %rdi.ptr.i64 = bitcast i8* %rdi.ptr.ph to i64*
  %elt.ptr.11c0 = getelementptr inbounds i64, i64* %rdi.ptr.i64, i64 %rbx.cur.ph
  %rdx.val = load i64, i64* %elt.ptr.11c0, align 8

  ; rax = rdx*8 - rdx = rdx*7
  %mul8 = mul i64 %rdx.val, 8
  %rax.tmp = sub i64 %mul8, %rdx.val

  ; eax = dword ptr [var_F8 + (rax*4)]
  %off.bytes = mul i64 %rax.tmp, 4
  %addr.varF8 = getelementptr inbounds i8, i8* %varF8.p0, i64 %off.bytes
  %addr.varF8.i32 = bitcast i8* %addr.varF8 to i32*
  %eax.loaded = load i32, i32* %addr.varF8.i32, align 4

  br label %loc_11D3

; 0x11D3
loc_11D3:
  ; PHIs for loop header
  %rdi.ptr.ph2 = phi i8* [ %m, %loc_after_malloc ], [ %rdi.ptr.ph, %loc_11C0 ]
  %rbx.cur.ph2 = phi i64 [ 0, %loc_after_malloc ], [ %rbx.cur.ph, %loc_11C0 ]
  %rsi.cur.ph2 = phi i64 [ 1, %loc_after_malloc ], [ %rsi.cur.ph, %loc_11C0 ]
  %r12.base.ph2 = phi i8* [ %order.base.i8, %loc_after_malloc ], [ %r12.base.ph, %loc_11C0 ]
  %eax.prev = phi i32 [ 0, %loc_after_malloc ], [ %eax.loaded, %loc_11C0 ]

  ; rbx = rbx + 1
  %rbx.next = add i64 %rbx.cur.ph2, 1
  ; rdx = [rdi + rbx*8 - 8]  => (rbx.next - 1)
  %rdi.ptr.i64.11d3 = bitcast i8* %rdi.ptr.ph2 to i64*
  %idx.prev = add i64 %rbx.next, -1
  %elt.ptr.prev = getelementptr inbounds i64, i64* %rdi.ptr.i64.11d3, i64 %idx.prev
  %rdx.load.11d3 = load i64, i64* %elt.ptr.prev, align 8
  ; [r12 + rbx*8 - 8] = rdx
  %r12.ptr.i64 = bitcast i8* %r12.base.ph2 to i64*
  %order.slot.prev = getelementptr inbounds i64, i64* %r12.ptr.i64, i64 %idx.prev
  store i64 %rdx.load.11d3, i64* %order.slot.prev, align 8

  ; test eax,eax -> jz loc_1200
  %eax.iszero = icmp eq i32 %eax.prev, 0
  br i1 %eax.iszero, label %loc_1200, label %loc_11E5_then

; then-part between 0x11E5 and 0x11FD
loc_11E5_then:
  ; cmp dword [var_158], -1 ; If equal then enqueue 0
  %d0 = load i32, i32* %var158.p0, align 16
  %is.neg1 = icmp eq i32 %d0, -1
  br i1 %is.neg1, label %loc_11E5_body, label %loc_1200

loc_11E5_body:
  ; ecx = dword [var_158 + rdx*4] ; using base var_158[0]
  %rdx.mul4 = mul i64 %rdx.load.11d3, 4
  %var158.base.i8 = bitcast i32* %var158.p0 to i8*
  %addr.ecx = getelementptr inbounds i8, i8* %var158.base.i8, i64 %rdx.mul4
  %addr.ecx.i32 = bitcast i8* %addr.ecx to i32*
  %ecx.load = load i32, i32* %addr.ecx.i32, align 4
  ; [rdi + rsi*8] = 0 ; enqueue node 0
  %rdi.i64.enq = bitcast i8* %rdi.ptr.ph2 to i64*
  %enq.slot0 = getelementptr inbounds i64, i64* %rdi.i64.enq, i64 %rsi.cur.ph2
  store i64 0, i64* %enq.slot0, align 8
  ; rsi++ ; eax = ecx+1 ; [var_158] = eax
  %rsi.inc0 = add i64 %rsi.cur.ph2, 1
  %ecx.inc0 = add i32 %ecx.load, 1
  store i32 %ecx.inc0, i32* %var158.p0, align 16
  br label %loc_1200

; 0x1200
loc_1200:
  ; rcx = rdx*8 - rdx = rdx*7
  %mul8.1200 = mul i64 %rdx.load.11d3, 8
  %rcx.tmp = sub i64 %mul8.1200, %rdx.load.11d3
  ; r11d = dword [var_F4 + rcx*4]
  %rcx.mul4 = mul i64 %rcx.tmp, 4
  %addr.varF4.r11 = getelementptr inbounds i8, i8* %varF8.p0, i64 %rcx.mul4
  %addr.varF4.r11.i32 = bitcast i8* %addr.varF4.r11 to i32*
  %r11d = load i32, i32* %addr.varF4.r11.i32, align 4
  ; rax = rcx*4 (as byte offset)
  %rax.by = mul i64 %rcx.tmp, 4
  ; test r11d, jz loc_1240
  %r11.zero = icmp eq i32 %r11d, 0
  br i1 %r11.zero, label %loc_1240, label %loc_1224_then

; between 0x121D and 0x1236
loc_1224_then:
  ; cmp dword [var_158+4], -1
  %d1 = load i32, i32* %var158.p1, align 4
  %d1.isneg1 = icmp eq i32 %d1, -1
  br i1 %d1.isneg1, label %loc_1224_body, label %loc_1240

loc_1224_body:
  ; ecx = dword [var_158 + rdx*4]
  %addr.ecx2 = getelementptr inbounds i8, i8* %var158.base.i8, i64 %rdx.mul4
  %addr.ecx2.i32 = bitcast i8* %addr.ecx2 to i32*
  %ecx2 = load i32, i32* %addr.ecx2.i32, align 4
  ; [rdi + rsi*8] = 1
  %rdi.i64.1224 = bitcast i8* %rdi.ptr.ph2 to i64*
  %enq.slot1 = getelementptr inbounds i64, i64* %rdi.i64.1224, i64 %rsi.cur.ph2
  store i64 1, i64* %enq.slot1, align 8
  ; rsi++ ; [var_158+4] = ecx+1
  %ecx2.inc = add i32 %ecx2, 1
  store i32 %ecx2.inc, i32* %var158.p1, align 4
  br label %loc_1240

; 0x1240
loc_1240:
  ; r10d = dword [var_F4 + rax.by + 4]
  %addr.varF4.r10 = getelementptr inbounds i8, i8* %varF8.p0, i64 %rax.by
  %addr.varF4.r10.off4 = getelementptr inbounds i8, i8* %addr.varF4.r10, i64 4
  %addr.varF4.r10.i32 = bitcast i8* %addr.varF4.r10.off4 to i32*
  %r10d = load i32, i32* %addr.varF4.r10.i32, align 4
  %r10.zero = icmp eq i32 %r10d, 0
  br i1 %r10.zero, label %loc_1270, label %loc_1251_then

loc_1251_then:
  ; cmp dword [var_158+8], -1
  %d2 = load i32, i32* %var158.p2, align 8
  %d2.isneg1 = icmp eq i32 %d2, -1
  br i1 %d2.isneg1, label %loc_1251_body, label %loc_1270

loc_1251_body:
  %addr.ecx3 = getelementptr inbounds i8, i8* %var158.base.i8, i64 %rdx.mul4
  %addr.ecx3.i32 = bitcast i8* %addr.ecx3 to i32*
  %ecx3 = load i32, i32* %addr.ecx3.i32, align 4
  %rdi.i64.1251 = bitcast i8* %rdi.ptr.ph2 to i64*
  %enq.slot2 = getelementptr inbounds i64, i64* %rdi.i64.1251, i64 %rsi.cur.ph2
  store i64 2, i64* %enq.slot2, align 8
  %ecx3.inc = add i32 %ecx3, 1
  store i32 %ecx3.inc, i32* %var158.p2, align 8
  br label %loc_1270

; 0x1270
loc_1270:
  ; r9d = [var_EC + rax.by] (within varF8 region)
  %addr.varF8.r9 = getelementptr inbounds i8, i8* %varF8.p0, i64 %rax.by
  %addr.varF8.r9.i32 = bitcast i8* %addr.varF8.r9 to i32*
  %r9d = load i32, i32* %addr.varF8.r9.i32, align 4
  %r9.zero = icmp eq i32 %r9d, 0
  br i1 %r9.zero, label %loc_12A0, label %loc_1281_then

loc_1281_then:
  ; cmp [var_158+0xC], -1
  %d3 = load i32, i32* %var158.p3, align 4
  %d3.isneg1 = icmp eq i32 %d3, -1
  br i1 %d3.isneg1, label %loc_1281_body, label %loc_12A0

loc_1281_body:
  %addr.ecx4 = getelementptr inbounds i8, i8* %var158.base.i8, i64 %rdx.mul4
  %addr.ecx4.i32 = bitcast i8* %addr.ecx4 to i32*
  %ecx4 = load i32, i32* %addr.ecx4.i32, align 4
  %rdi.i64.1281 = bitcast i8* %rdi.ptr.ph2 to i64*
  %enq.slot3 = getelementptr inbounds i64, i64* %rdi.i64.1281, i64 %rsi.cur.ph2
  store i64 3, i64* %enq.slot3, align 8
  %ecx4.inc = add i32 %ecx4, 1
  store i32 %ecx4.inc, i32* %var158.p3, align 4
  br label %loc_12A0

; 0x12A0
loc_12A0:
  ; r8d = [var_E8 + rax.by]
  %addr.varF8.r8 = getelementptr inbounds i8, i8* %varF8.p0, i64 %rax.by
  %addr.varF8.r8.i32 = bitcast i8* %addr.varF8.r8 to i32*
  %r8d = load i32, i32* %addr.varF8.r8.i32, align 4
  %r8.zero = icmp eq i32 %r8d, 0
  br i1 %r8.zero, label %loc_12D0, label %loc_12B1_then

loc_12B1_then:
  ; cmp [var_148], -1
  %v148 = load i32, i32* %var148, align 4
  %v148.isneg1 = icmp eq i32 %v148, -1
  br i1 %v148.isneg1, label %loc_12B1_body, label %loc_12D0

loc_12B1_body:
  %addr.ecx5 = getelementptr inbounds i8, i8* %var158.base.i8, i64 %rdx.mul4
  %addr.ecx5.i32 = bitcast i8* %addr.ecx5 to i32*
  %ecx5 = load i32, i32* %addr.ecx5.i32, align 4
  %rdi.i64.12b1 = bitcast i8* %rdi.ptr.ph2 to i64*
  %enq.slot4 = getelementptr inbounds i64, i64* %rdi.i64.12b1, i64 %rsi.cur.ph2
  store i64 4, i64* %enq.slot4, align 8
  %ecx5.inc = add i32 %ecx5, 1
  store i32 %ecx5.inc, i32* %var148, align 4
  br label %loc_12D0

; 0x12D0
loc_12D0:
  ; ecx = [var_E4 + rax.by]
  %addr.varF8.ecx = getelementptr inbounds i8, i8* %varF8.p0, i64 %rax.by
  %addr.varF8.ecx.i32 = bitcast i8* %addr.varF8.ecx to i32*
  %ecx6 = load i32, i32* %addr.varF8.ecx.i32, align 4
  %ecx6.zero = icmp eq i32 %ecx6, 0
  br i1 %ecx6.zero, label %loc_12F8, label %loc_12DF_then

loc_12DF_then:
  ; cmp [var_144], -1
  %v144 = load i32, i32* %var144, align 4
  %v144.isneg1 = icmp eq i32 %v144, -1
  br i1 %v144.isneg1, label %loc_12DF_body, label %loc_12F8

loc_12DF_body:
  %addr.ecx7 = getelementptr inbounds i8, i8* %var158.base.i8, i64 %rdx.mul4
  %addr.ecx7.i32 = bitcast i8* %addr.ecx7 to i32*
  %ecx7 = load i32, i32* %addr.ecx7.i32, align 4
  %rdi.i64.12df = bitcast i8* %rdi.ptr.ph2 to i64*
  %enq.slot5 = getelementptr inbounds i64, i64* %rdi.i64.12df, i64 %rsi.cur.ph2
  store i64 5, i64* %enq.slot5, align 8
  %ecx7.inc = add i32 %ecx7, 1
  store i32 %ecx7.inc, i32* %var144, align 4
  br label %loc_12F8

; 0x12F8
loc_12F8:
  ; eax = [var_E0 + rax.by]
  %addr.varF8.eax = getelementptr inbounds i8, i8* %varF8.p0, i64 %rax.by
  %addr.varF8.eax.i32 = bitcast i8* %addr.varF8.eax to i32*
  %eax6 = load i32, i32* %addr.varF8.eax.i32, align 4
  %eax6.zero = icmp eq i32 %eax6, 0
  br i1 %eax6.zero, label %loc_1320, label %loc_1307_then

loc_1307_then:
  ; cmp [var_140], -1
  %v140 = load i32, i32* %var140, align 4
  %v140.isneg1 = icmp eq i32 %v140, -1
  br i1 %v140.isneg1, label %loc_1307_body, label %loc_1320

loc_1307_body:
  %addr.eax8 = getelementptr inbounds i8, i8* %var158.base.i8, i64 %rdx.mul4
  %addr.eax8.i32 = bitcast i8* %addr.eax8 to i32*
  %eax8 = load i32, i32* %addr.eax8.i32, align 4
  %rdi.i64.1307 = bitcast i8* %rdi.ptr.ph2 to i64*
  %enq.slot6 = getelementptr inbounds i64, i64* %rdi.i64.1307, i64 %rsi.cur.ph2
  store i64 6, i64* %enq.slot6, align 8
  %eax8.inc = add i32 %eax8, 1
  store i32 %eax8.inc, i32* %var140, align 4
  br label %loc_1320

; 0x1320
loc_1320:
  ; rbx < rsi ? back to 11C0 : exit loop
  %rsi.cur = phi i64 [ %rsi.cur.ph2, %loc_1200 ], [ %rsi.cur.ph2, %loc_1224_then ], [ %rsi.inc0, %loc_11E5_body ], [ %rsi.cur.ph2, %loc_1240 ], [ %rsi.cur.ph2, %loc_1251_then ], [ %rsi.cur.ph2, %loc_1251_body ], [ %rsi.cur.ph2, %loc_1270 ], [ %rsi.cur.ph2, %loc_1281_then ], [ %rsi.cur.ph2, %loc_1281_body ], [ %rsi.cur.ph2, %loc_12A0 ], [ %rsi.cur.ph2, %loc_12B1_then ], [ %rsi.cur.ph2, %loc_12B1_body ], [ %rsi.cur.ph2, %loc_12D0 ], [ %rsi.cur.ph2, %loc_12DF_then ], [ %rsi.cur.ph2, %loc_12DF_body ], [ %rsi.cur.ph2, %loc_12F8 ], [ %rsi.cur.ph2, %loc_1307_then ], [ %rsi.cur.ph2, %loc_1307_body ]
  %rbx.cur.ph2 = phi i64 [ %rbx.next, %loc_1200 ], [ %rbx.next, %loc_1224_then ], [ %rbx.next, %loc_11E5_body ], [ %rbx.next, %loc_1240 ], [ %rbx.next, %loc_1251_then ], [ %rbx.next, %loc_1251_body ], [ %rbx.next, %loc_1270 ], [ %rbx.next, %loc_1281_then ], [ %rbx.next, %loc_1281_body ], [ %rbx.next, %loc_12A0 ], [ %rbx.next, %loc_12B1_then ], [ %rbx.next, %loc_12B1_body ], [ %rbx.next, %loc_12D0 ], [ %rbx.next, %loc_12DF_then ], [ %rbx.next, %loc_12DF_body ], [ %rbx.next, %loc_12F8 ], [ %rbx.next, %loc_1307_then ], [ %rbx.next, %loc_1307_body ]
  %r12.base.ph2 = phi i8* [ %r12.base.ph2, %loc_1200 ], [ %r12.base.ph2, %loc_1224_then ], [ %r12.base.ph2, %loc_11E5_body ], [ %r12.base.ph2, %loc_1240 ], [ %r12.base.ph2, %loc_1251_then ], [ %r12.base.ph2, %loc_1251_body ], [ %r12.base.ph2, %loc_1270 ], [ %r12.base.ph2, %loc_1281_then ], [ %r12.base.ph2, %loc_1281_body ], [ %r12.base.ph2, %loc_12A0 ], [ %r12.base.ph2, %loc_12B1_then ], [ %r12.base.ph2, %loc_12B1_body ], [ %r12.base.ph2, %loc_12D0 ], [ %r12.base.ph2, %loc_12DF_then ], [ %r12.base.ph2, %loc_12DF_body ], [ %r12.base.ph2, %loc_12F8 ], [ %r12.base.ph2, %loc_1307_then ], [ %r12.base.ph2, %loc_1307_body ]
  %rdi.ptr.ph2 = phi i8* [ %rdi.ptr.ph2, %loc_1200 ], [ %rdi.ptr.ph2, %loc_1224_then ], [ %rdi.ptr.ph2, %loc_11E5_body ], [ %rdi.ptr.ph2, %loc_1240 ], [ %rdi.ptr.ph2, %loc_1251_then ], [ %rdi.ptr.ph2, %loc_1251_body ], [ %rdi.ptr.ph2, %loc_1270 ], [ %rdi.ptr.ph2, %loc_1281_then ], [ %rdi.ptr.ph2, %loc_1281_body ], [ %rdi.ptr.ph2, %loc_12A0 ], [ %rdi.ptr.ph2, %loc_12B1_then ], [ %rdi.ptr.ph2, %loc_12B1_body ], [ %rdi.ptr.ph2, %loc_12D0 ], [ %rdi.ptr.ph2, %loc_12DF_then ], [ %rdi.ptr.ph2, %loc_12DF_body ], [ %rdi.ptr.ph2, %loc_12F8 ], [ %rdi.ptr.ph2, %loc_1307_then ], [ %rdi.ptr.ph2, %loc_1307_body ]
  %cmp.rbx.rsi = icmp ult i64 %rbx.cur.ph2, %rsi.cur
  br i1 %cmp.rbx.rsi, label %loc_11C0, label %loc_after_loop

loc_after_loop:
  ; _free(rdi)
  call void @_free(i8* noundef %rdi.ptr.ph2)
  ; printf_chk(2, "BFS order from %zu: ", (size_t)0)
  %fmt.bfs.p0 = getelementptr inbounds [21 x i8], [21 x i8]* @.str_bfs, i64 0, i64 0
  %call.printf.bfs = call i32 (i32, i8*, ...) @___printf_chk(i32 noundef 2, i8* noundef %fmt.bfs.p0, i64 noundef 0)

  ; r13 = "%zu%s" (we'll just keep it as constant)
  %r13.ptr = getelementptr inbounds [6 x i8], [6 x i8]* @.str_zu_s, i64 0, i64 0

  ; rdx = order[0]
  %order0 = load i64, i64* %order.base, align 16
  ; if (rbx != 1) goto 13DD else 1360
  %rbx.ne1 = icmp ne i64 %rbx.cur.ph2, 1
  br i1 %rbx.ne1, label %loc_13DD, label %loc_1360

; 0x1360
loc_1360:
  ; printf_chk(2, "%zu%s", order0, "")
  %empty.ptr = getelementptr inbounds [23 x i8], [23 x i8]* @.str_dist, i64 0, i64 22
  %fmt.zu.s = getelementptr inbounds [6 x i8], [6 x i8]* @.str_zu_s, i64 0, i64 0
  %call.first.elem = call i32 (i32, i8*, ...) @___printf_chk(i32 noundef 2, i8* noundef %fmt.zu.s, i64 noundef %order0, i8* noundef %empty.ptr)
  br label %loc_1376

; 0x1376
loc_1376:
  ; printf_chk(2, "\n")
  %newline.ptr = getelementptr inbounds [23 x i8], [23 x i8]* @.str_dist, i64 0, i64 21
  %call.newline = call i32 (i32, i8*, ...) @___printf_chk(i32 noundef 2, i8* noundef %newline.ptr)
  ; ebx = 0
  br label %loc_138b

; 0x138b (setup for distances)
loc_138b:
  ; r12 = base of distances array (use var_158 as source)
  %dist.base = bitcast i32* %var158.p0 to i32*
  br label %loc_1398

; 0x1398
loc_1398:
  ; PHI for index rbx over 0..6
  %rbx.dist = phi i64 [ 0, %loc_138b ], [ %rbx.next2, %loc_13AF_ret ]
  ; r8d = [r12 + rbx*4] => dist[rbx]
  %idx32 = trunc i64 %rbx.dist to i32
  %idx.ext = zext i32 %idx32 to i64
  %dist.ptr = getelementptr inbounds i32, i32* %dist.base, i64 %idx.ext
  %dist.val = load i32, i32* %dist.ptr, align 4
  ; rcx = rbx ; edx = 0 ; rsi = fmt
  %fmt.dist = getelementptr inbounds [23 x i8], [23 x i8]* @.str_dist, i64 0, i64 0
  %call.dist = call i32 (i32, i8*, ...) @___printf_chk(i32 noundef 2, i8* noundef %fmt.dist, i64 noundef 0, i64 noundef %rbx.dist, i32 noundef %dist.val)
  br label %loc_13AF_ret

; fall-through after call
loc_13AF_ret:
  ; rbx++ ; compare with 7 ; jnz loc_1398
  %rbx.next2 = add i64 %rbx.dist, 1
  %cmp7 = icmp ne i64 %rbx.next2, 7
  br i1 %cmp7, label %loc_1398, label %loc_13BA_done

; 0x13BA epilogue check
loc_13BA_done:
  ; stack canary check
  %guard.saved = load i64, i64* %canary.save, align 8
  %guard.cur = load i64, i64* @__stack_chk_guard, align 8
  %canary.ok = icmp eq i64 %guard.saved, %guard.cur
  br i1 %canary.ok, label %loc_13CD_ret, label %loc_142E

; normal return sequence (0x13CD..0x13DC)
loc_13CD_ret:
  ret i32 0

; 0x13DD
loc_13DD:
  ; r12 = r12 + rbx*8  (end pointer), with r12 base = &order[0]
  %r12.end.ptr = getelementptr inbounds i64, i64* %order.base, i64 %rbx.cur.ph2
  ; rbp = &order[1]
  %rbp.start = getelementptr inbounds i64, i64* %order.base, i64 1
  ; rbx(reg) = " "
  %space.ptr = getelementptr inbounds [21 x i8], [21 x i8]* @.str_bfs, i64 0, i64 19
  br label %loc_13F0

; 0x13F0
loc_13F0:
  ; PHIs: current printed value in rdx, and rbp loop cursor
  %rdx.cur = phi i64 [ %order0, %loc_13DD ], [ %rdx.next, %loc_140D_check ]
  %rbp.cur = phi i64* [ %rbp.start, %loc_13DD ], [ %rbp.next, %loc_140D_check ]
  ; printf_chk(2, "%zu%s", rdx.cur, " ")
  %fmt.zu.s.2 = getelementptr inbounds [6 x i8], [6 x i8]* @.str_zu_s, i64 0, i64 0
  %call.loop.elem = call i32 (i32, i8*, ...) @___printf_chk(i32 noundef 2, i8* noundef %fmt.zu.s.2, i64 noundef %rdx.cur, i8* noundef %space.ptr)
  ; rbp += 8 ; rdx = [rbp-8]
  %rbp.next = getelementptr inbounds i64, i64* %rbp.cur, i64 1
  %rbp.prev.ptr = getelementptr inbounds i64, i64* %rbp.next, i64 -1
  %rdx.next = load i64, i64* %rbp.prev.ptr, align 8
  br label %loc_140D_check

; 0x140D
loc_140D_check:
  ; if rbp != r12.end, loop; else jump to 1360
  %done = icmp eq i64* %rbp.next, %r12.end.ptr
  br i1 %done, label %loc_1360, label %loc_13F0

; 0x1414
loc_1414:
  ; malloc failed: print header and go to 1376
  %fmt.bfs.p0.2 = getelementptr inbounds [21 x i8], [21 x i8]* @.str_bfs, i64 0, i64 0
  %call.printf.bfs.fail = call i32 (i32, i8*, ...) @___printf_chk(i32 noundef 2, i8* noundef %fmt.bfs.p0.2, i64 noundef 0)
  br label %loc_1376

; 0x142E
loc_142E:
  call void @___stack_chk_fail()
  unreachable
}

declare void @llvm.memset.p0i8.i64(i8* nocapture, i8, i64, i1 immarg)