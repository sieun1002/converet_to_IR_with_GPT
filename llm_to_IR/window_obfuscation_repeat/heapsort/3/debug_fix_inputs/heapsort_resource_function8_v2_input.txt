; === ERROR LOG BEGIN [llvm-as] ===
; llvm-as-14: assembly parsed, but does not verify as correct!
; Intrinsic has incorrect argument type!
; void (i8**)* @llvm.va_start
; Intrinsic has incorrect argument type!
; void (i8**)* @llvm.va_end
; === ERROR LOG END ===

; ModuleID = 'fixed_module'
target triple = "x86_64-pc-windows-msvc"

@Format = internal unnamed_addr constant [9 x i8] c"Before: \00", align 1
@aD = internal unnamed_addr constant [4 x i8] c"%d \00", align 1
@byte_14000400D = internal unnamed_addr constant [8 x i8] c"After: \00", align 1

declare i32 @printf(i8*, ...)
declare i32 @vprintf(i8*, i8*)
declare i32 @putchar(i32)
declare void @llvm.va_start(i8**)
declare void @llvm.va_end(i8**)

define void @sub_1400018F0() {
entry:
  ret void
}

define i32 @sub_140002960(i8* %fmt, ...) {
entry:
  %ap = alloca i8*, align 8
  call void @llvm.va_start(i8** %ap)
  %ap_val = load i8*, i8** %ap, align 8
  %call = call i32 @vprintf(i8* %fmt, i8* %ap_val)
  call void @llvm.va_end(i8** %ap)
  ret i32 %call
}

define void @sub_140001450(i32* %arr, i64 %n) {
entry:
  %cmp_init = icmp ult i64 %n, 2
  br i1 %cmp_init, label %ret, label %outer_init

outer_init:
  %i = alloca i64, align 8
  %j = alloca i64, align 8
  store i64 0, i64* %i, align 8
  br label %outer_cond

outer_cond:
  %i_val = load i64, i64* %i, align 8
  %cond_outer = icmp ult i64 %i_val, %n
  br i1 %cond_outer, label %inner_prep, label %ret

inner_prep:
  %n_minus_1 = sub i64 %n, 1
  %limit = sub i64 %n_minus_1, %i_val
  store i64 0, i64* %j, align 8
  br label %inner_cond

inner_cond:
  %j_val = load i64, i64* %j, align 8
  %cond_inner = icmp ult i64 %j_val, %limit
  br i1 %cond_inner, label %inner_body, label %outer_inc

inner_body:
  %idx_j = getelementptr inbounds i32, i32* %arr, i64 %j_val
  %j_next = add i64 %j_val, 1
  %idx_j1 = getelementptr inbounds i32, i32* %arr, i64 %j_next
  %val_j = load i32, i32* %idx_j, align 4
  %val_j1 = load i32, i32* %idx_j1, align 4
  %cmp_swap = icmp sgt i32 %val_j, %val_j1
  br i1 %cmp_swap, label %do_swap, label %no_swap

do_swap:
  store i32 %val_j, i32* %idx_j1, align 4
  store i32 %val_j1, i32* %idx_j, align 4
  br label %inc_j

no_swap:
  br label %inc_j

inc_j:
  %j_next2 = add i64 %j_val, 1
  store i64 %j_next2, i64* %j, align 8
  br label %inner_cond

outer_inc:
  %i_next = add i64 %i_val, 1
  store i64 %i_next, i64* %i, align 8
  br label %outer_cond

ret:
  ret void
}

define i32 @sub_14000171D() {
entry:
  %arr = alloca [9 x i32], align 16
  %n = alloca i64, align 8
  %i = alloca i64, align 8
  %i2 = alloca i64, align 8
  call void @sub_1400018F0()
  %arr0 = getelementptr inbounds [9 x i32], [9 x i32]* %arr, i64 0, i64 0
  store i32 7, i32* %arr0, align 4
  %arr1 = getelementptr inbounds [9 x i32], [9 x i32]* %arr, i64 0, i64 1
  store i32 3, i32* %arr1, align 4
  %arr2 = getelementptr inbounds [9 x i32], [9 x i32]* %arr, i64 0, i64 2
  store i32 9, i32* %arr2, align 4
  %arr3 = getelementptr inbounds [9 x i32], [9 x i32]* %arr, i64 0, i64 3
  store i32 1, i32* %arr3, align 4
  %arr4 = getelementptr inbounds [9 x i32], [9 x i32]* %arr, i64 0, i64 4
  store i32 4, i32* %arr4, align 4
  %arr5 = getelementptr inbounds [9 x i32], [9 x i32]* %arr, i64 0, i64 5
  store i32 8, i32* %arr5, align 4
  %arr6 = getelementptr inbounds [9 x i32], [9 x i32]* %arr, i64 0, i64 6
  store i32 2, i32* %arr6, align 4
  %arr7 = getelementptr inbounds [9 x i32], [9 x i32]* %arr, i64 0, i64 7
  store i32 6, i32* %arr7, align 4
  %arr8 = getelementptr inbounds [9 x i32], [9 x i32]* %arr, i64 0, i64 8
  store i32 5, i32* %arr8, align 4
  store i64 9, i64* %n, align 8
  %fmt_before_ptr = getelementptr inbounds [9 x i8], [9 x i8]* @Format, i64 0, i64 0
  %call_print_before = call i32 (i8*, ...) @sub_140002960(i8* %fmt_before_ptr)
  store i64 0, i64* %i, align 8
  br label %loop_cond

loop_cond:
  %i_val = load i64, i64* %i, align 8
  %n_val = load i64, i64* %n, align 8
  %cmp = icmp ult i64 %i_val, %n_val
  br i1 %cmp, label %loop_body, label %after_first_print

loop_body:
  %elem_ptr = getelementptr inbounds [9 x i32], [9 x i32]* %arr, i64 0, i64 %i_val
  %elem = load i32, i32* %elem_ptr, align 4
  %fmt_d_ptr = getelementptr inbounds [4 x i8], [4 x i8]* @aD, i64 0, i64 0
  %call_print_elem = call i32 (i8*, ...) @sub_140002960(i8* %fmt_d_ptr, i32 %elem)
  %i_next = add i64 %i_val, 1
  store i64 %i_next, i64* %i, align 8
  br label %loop_cond

after_first_print:
  %nl1 = call i32 @putchar(i32 10)
  %arr_base = getelementptr inbounds [9 x i32], [9 x i32]* %arr, i64 0, i64 0
  %n_for_sort = load i64, i64* %n, align 8
  call void @sub_140001450(i32* %arr_base, i64 %n_for_sort)
  %fmt_after_ptr = getelementptr inbounds [8 x i8], [8 x i8]* @byte_14000400D, i64 0, i64 0
  %call_print_after = call i32 (i8*, ...) @sub_140002960(i8* %fmt_after_ptr)
  store i64 0, i64* %i2, align 8
  br label %loop2_cond

loop2_cond:
  %i2_val = load i64, i64* %i2, align 8
  %n_val2 = load i64, i64* %n, align 8
  %cmp2 = icmp ult i64 %i2_val, %n_val2
  br i1 %cmp2, label %loop2_body, label %after_second_print

loop2_body:
  %elem_ptr2 = getelementptr inbounds [9 x i32], [9 x i32]* %arr, i64 0, i64 %i2_val
  %elem2 = load i32, i32* %elem_ptr2, align 4
  %fmt_d_ptr2 = getelementptr inbounds [4 x i8], [4 x i8]* @aD, i64 0, i64 0
  %call_print_elem2 = call i32 (i8*, ...) @sub_140002960(i8* %fmt_d_ptr2, i32 %elem2)
  %i2_next = add i64 %i2_val, 1
  store i64 %i2_next, i64* %i2, align 8
  br label %loop2_cond

after_second_print:
  %nl2 = call i32 @putchar(i32 10)
  ret i32 0
}