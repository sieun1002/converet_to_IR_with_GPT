; === ERROR LOG BEGIN [llvm-as] ===
; llvm-as-14: assembly parsed, but does not verify as correct!
; PHI nodes not grouped at top of basic block!
;   %idx = phi i32 [ 0, %entry ], [ %idx.next, %scan.next ]
; label %scan.loop
; === ERROR LOG END ===

; ModuleID = 'fixed_module'
target triple = "x86_64-pc-windows-msvc"
target datalayout = "e-m:w-i64:64-f80:128-n8:16:32:64-S128"

%MBI = type { i8*, i8*, i32, i32, i64, i32, i32, i32 }

@dword_1400070A4 = external global i32
@qword_1400070A8 = external global i8*

@aVirtualprotect = internal unnamed_addr constant [39 x i8] c"  VirtualProtect failed with code 0x%x\00"
@aVirtualqueryFa = internal unnamed_addr constant [49 x i8] c"  VirtualQuery failed for %d bytes at address %p\00"
@aAddressPHasNoI = internal unnamed_addr constant [32 x i8] c"Address %p has no image-section\00"

declare i8* @sub_140002610(i8* noundef)
declare i8* @sub_140002750()
declare i32 @sub_140001AD0(i8* noundef, ...)
declare i64 @VirtualQuery(i8* noundef, %MBI* noundef, i64 noundef)
declare i32 @VirtualProtect(i8* noundef, i64 noundef, i32 noundef, i32* noundef)
declare i32 @GetLastError()

define void @sub_140001B30(i8* noundef %addr) local_unnamed_addr {
entry:
  %count = load i32, i32* @dword_1400070A4, align 4
  %has_entries = icmp sgt i32 %count, 0
  br i1 %has_entries, label %scan.loop, label %build.new

scan.loop:
  %base.ptr0 = load i8*, i8** @qword_1400070A8, align 8
  %idx = phi i32 [ 0, %entry ], [ %idx.next, %scan.next ]
  %idx64 = zext i32 %idx to i64
  %off.bytes = mul i64 %idx64, 40
  %entry.ptr = getelementptr inbounds i8, i8* %base.ptr0, i64 %off.bytes
  %ptr.plus18 = getelementptr inbounds i8, i8* %entry.ptr, i64 24
  %regionBase.pp = bitcast i8* %ptr.plus18 to i8**
  %regionBase = load i8*, i8** %regionBase.pp, align 8
  %addr.i = ptrtoint i8* %addr to i64
  %regionBase.i = ptrtoint i8* %regionBase to i64
  %addr_lt_base = icmp ult i64 %addr.i, %regionBase.i
  br i1 %addr_lt_base, label %scan.next, label %check.end

check.end:
  %ptr.plus8 = getelementptr inbounds i8, i8* %entry.ptr, i64 8
  %p.pp = bitcast i8* %ptr.plus8 to i8**
  %p.struct = load i8*, i8** %p.pp, align 8
  %len.ptr.i8 = getelementptr inbounds i8, i8* %p.struct, i64 8
  %len.ptr = bitcast i8* %len.ptr.i8 to i32*
  %len32 = load i32, i32* %len.ptr, align 4
  %len64 = zext i32 %len32 to i64
  %end.i = add i64 %regionBase.i, %len64
  %in.range = icmp ult i64 %addr.i, %end.i
  br i1 %in.range, label %early.ret, label %scan.next

scan.next:
  %idx.next = add i32 %idx, 1
  %cont = icmp slt i32 %idx.next, %count
  br i1 %cont, label %scan.loop, label %build.new

early.ret:
  ret void

build.new:
  %pinfo = call i8* @sub_140002610(i8* noundef %addr)
  %isnull = icmp eq i8* %pinfo, null
  br i1 %isnull, label %no.image.section, label %have.info

no.image.section:
  %fmt.noimg.ptr = getelementptr inbounds [32 x i8], [32 x i8]* @aAddressPHasNoI, i64 0, i64 0
  %call.print.noimg = call i32 (i8*, ...) @sub_140001AD0(i8* noundef %fmt.noimg.ptr, i8* noundef %addr)
  ret void

have.info:
  %base.ptr1 = load i8*, i8** @qword_1400070A8, align 8
  %count64 = zext i32 %count to i64
  %off.bytes.new = mul i64 %count64, 40
  %entry.ptr.new = getelementptr inbounds i8, i8* %base.ptr1, i64 %off.bytes.new
  %slot20 = getelementptr inbounds i8, i8* %entry.ptr.new, i64 32
  %slot20.pp = bitcast i8* %slot20 to i8**
  store i8* %pinfo, i8** %slot20.pp, align 8
  %entry.dw0 = bitcast i8* %entry.ptr.new to i32*
  store i32 0, i32* %entry.dw0, align 4
  %base2 = call i8* @sub_140002750()
  %off32.ptr.i8 = getelementptr inbounds i8, i8* %pinfo, i64 12
  %off32.ptr = bitcast i8* %off32.ptr.i8 to i32*
  %off32 = load i32, i32* %off32.ptr, align 4
  %off64 = zext i32 %off32 to i64
  %target.addr = getelementptr inbounds i8, i8* %base2, i64 %off64
  %slot18 = getelementptr inbounds i8, i8* %entry.ptr.new, i64 24
  %slot18.pp = bitcast i8* %slot18 to i8**
  store i8* %target.addr, i8** %slot18.pp, align 8
  %mbi = alloca %MBI, align 8
  %vq.ret = call i64 @VirtualQuery(i8* noundef %target.addr, %MBI* noundef %mbi, i64 noundef 48)
  %vq.ok = icmp ne i64 %vq.ret, 0
  br i1 %vq.ok, label %after.vq, label %vq.fail

vq.fail:
  %base.ptr2 = load i8*, i8** @qword_1400070A8, align 8
  %bytes.ptr.i8 = getelementptr inbounds i8, i8* %pinfo, i64 8
  %bytes.ptr = bitcast i8* %bytes.ptr.i8 to i32*
  %bytes = load i32, i32* %bytes.ptr, align 4
  %slot18.for.print = getelementptr inbounds i8, i8* %base.ptr2, i64 %off.bytes.new
  %slot18.addr.i8 = getelementptr inbounds i8, i8* %slot18.for.print, i64 24
  %slot18.addr.pp = bitcast i8* %slot18.addr.i8 to i8**
  %lpAddress.to.print = load i8*, i8** %slot18.addr.pp, align 8
  %fmt.vq.ptr = getelementptr inbounds [49 x i8], [49 x i8]* @aVirtualqueryFa, i64 0, i64 0
  %call.print.vq = call i32 (i8*, ...) @sub_140001AD0(i8* noundef %fmt.vq.ptr, i32 noundef %bytes, i8* noundef %lpAddress.to.print)
  ret void

after.vq:
  %prot.ptr = getelementptr inbounds %MBI, %MBI* %mbi, i64 0, i32 6
  %prot = load i32, i32* %prot.ptr, align 4
  %is4 = icmp eq i32 %prot, 4
  %is8 = icmp eq i32 %prot, 8
  %is40 = icmp eq i32 %prot, 64
  %is80 = icmp eq i32 %prot, 128
  %ok.or1 = or i1 %is4, %is8
  %ok.or2 = or i1 %is40, %is80
  %ok.final = or i1 %ok.or1, %ok.or2
  br i1 %ok.final, label %inc.ret, label %do.vp

do.vp:
  %baseaddr.ptr = getelementptr inbounds %MBI, %MBI* %mbi, i64 0, i32 0
  %baseaddr = load i8*, i8** %baseaddr.ptr, align 8
  %regionsize.ptr = getelementptr inbounds %MBI, %MBI* %mbi, i64 0, i32 4
  %regionsize = load i64, i64* %regionsize.ptr, align 8
  %entry.plus8 = getelementptr inbounds i8, i8* %entry.ptr.new, i64 8
  %entry.plus8.pp = bitcast i8* %entry.plus8 to i8**
  store i8* %baseaddr, i8** %entry.plus8.pp, align 8
  %entry.plus16 = getelementptr inbounds i8, i8* %entry.ptr.new, i64 16
  %entry.plus16.p = bitcast i8* %entry.plus16 to i64*
  store i64 %regionsize, i64* %entry.plus16.p, align 8
  %is.readonly = icmp eq i32 %prot, 2
  %newprot = select i1 %is.readonly, i32 4, i32 64
  %oldprot.ptr = bitcast i8* %entry.ptr.new to i32*
  %vp.ok = call i32 @VirtualProtect(i8* noundef %baseaddr, i64 noundef %regionsize, i32 noundef %newprot, i32* noundef %oldprot.ptr)
  %vp.success = icmp ne i32 %vp.ok, 0
  br i1 %vp.success, label %inc.ret, label %vp.fail

vp.fail:
  %err = call i32 @GetLastError()
  %fmt.vp.ptr = getelementptr inbounds [39 x i8], [39 x i8]* @aVirtualprotect, i64 0, i64 0
  %call.print.vp = call i32 (i8*, ...) @sub_140001AD0(i8* noundef %fmt.vp.ptr, i32 noundef %err)
  ret void

inc.ret:
  %oldcnt = load i32, i32* @dword_1400070A4, align 4
  %newcnt = add i32 %oldcnt, 1
  store i32 %newcnt, i32* @dword_1400070A4, align 4
  ret void
}